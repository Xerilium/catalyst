---
id: [feature-id]
title: [feature-name]
author: [architect]
description: "This document defines the implementation plan for the {feature-name} feature for engineers. The document is generated by Catalyst AI and reviewed by the feature architect."
dependencies:
  - [list-of-dependent-feature-ids]
---

<!-- markdownlint-disable single-title -->

# Implementation Plan: {feature-name}

> [CRITICAL INSTRUCTION]
> This implementation plan describes the full implementation of the feature **from scratch**, as if no code exists. Do NOT write this as an enhancement or modification to existing code. Use language like "Create", "Implement", "Build" - NOT "Modify", "Add to", "Update".

**Spec**: [Feature spec](./spec.md)

---

## Summary

> [INSTRUCTIONS]
> One concise paragraph (3-5 sentences) that combines:
>
> - What the feature does (from spec.md)
> - How it will be implemented (high-level technical approach)
> - What it enables (user/system benefit)
>
> This summary should be readable by both engineers and architects. Avoid implementation details - save those for "Implementation Approach" section.
>
> **Design rationale**: Reference `research.md` for detailed analysis of alternatives, decisions, and tradeoffs. Do NOT duplicate research findings here.

---

## Technical Context

This feature implementation plan extends the technical architecture defined in `.xe/architecture.md`.

**Feature-specific technical details:**

> [INSTRUCTIONS]
> Include essential technical details AI needs during code generation. Focus on feature-specific constraints and targets - not system-wide architecture. Use bullet points with bold labels:
>
> - **Primary Components**: [main functions/classes/modules this feature introduces]
> - **Data Structures**: [key data formats, schemas, types]
> - **Dependencies**: [other features/libraries this depends on]
> - **Configuration**: [config files, settings, environment variables, defaults]
> - **Performance Goals**: [specific measurable targets: <100ms, >1000 req/s, <50MB memory]
> - **Testing Framework**: [test framework and coverage target if different from system default]
> - **Key Constraints**: [feature-specific limits, security requirements, offline requirements]
>
> Include essentials from `.xe/architecture.md` that AI needs for implementation (testing framework, language version, key patterns). Do NOT duplicate the entire architecture document.

---

## Project Structure

> [INSTRUCTIONS]
> Show folder architecture and primary entry point files this feature creates. Focus on structure, not exhaustive file lists.
>
> **When to list individual files:**
> - Feature has â‰¤10 key files AND file organization illustrates a specific architectural pattern (e.g., adapter pattern, plugin architecture)
> - Otherwise, show folders only with descriptions of what goes in them
>
> **Comments:** Only add inline comments when clarifying non-obvious purpose. Omit comments for self-documenting filenames (types.ts, errors.ts, models/, tests/).
>
> Example (Backend with folder-only structure):
> ```
> src/
>   api/                  # Task CRUD endpoints
>   models/               # Task data models
>   services/             # Task business logic
> tests/
>   unit/                 # Unit tests for models/services
>   integration/          # API integration tests
> ```
>
> Example (Frontend with files showing pattern):
> ```
> src/
>   hooks/useTasks.ts     # Main data fetching hook
>   types/task.ts         # Type definitions
>   api/tasks.ts          # API client
>   components/TaskList/  # UI components
> tests/components/       # Component tests
> ```

---

## Data Model

**Entities owned by this feature:**

> [INSTRUCTIONS]
> Document entities inline. For each: name, purpose, key fields with types, relationships. Only create separate `data-model.md` if 3+ complex entities with state machines.
>
> Example:
>
> - **Task**: User task with priority and completion tracking
>   - `id`: string (UUID)
>   - `title`: string (max 200 chars)
>   - `status`: 'pending' | 'in_progress' | 'completed'
>   - `priority`: number (1-10)
>   - `assignedTo`: User (relationship)

**Entities from other features:**

> [INSTRUCTIONS]
> List consumed entities with source feature. Example: **User** (from auth feature), **Project** (from project-management)

---

## Contracts

> [INSTRUCTIONS]
> **ALWAYS document contracts inline here** - AI needs this during code generation. Define function signatures or API endpoints depending on feature type. Use the tech-agnostic format below for consistency.

### [Function/Endpoint/Class Name]

**Signature:**

```
[Complete function/method/endpoint declaration in target language syntax]
```

**Purpose:** [One sentence describing what this does]

**Parameters:**

- `param1` ([type]): [Description]
- `param2` ([type], optional): [Description with default value if applicable]

**Returns:** [Return type and description]

**Errors/Exceptions:** [What can fail and why, if applicable]

**Examples:**

```
[Basic usage example showing minimal parameters]
```

```
[Advanced usage example with optional parameters]
```

> [NOTE FOR AI]
> For REST APIs: Also generate OpenAPI schema in `.xe/features/{feature-id}/contracts/api.yaml` and reference here: "Full API specification: See contracts/api.yaml"
>
> For GraphQL APIs: Generate schema in `.xe/features/{feature-id}/contracts/schema.graphql` and reference here: "Full GraphQL schema: See contracts/schema.graphql"

---

## Implementation Approach

> [INSTRUCTIONS]
> This is the CORE section - describe HOW to build the feature from scratch.
>
> **Structure:** Use H3 subsections (### 1., ### 2., etc.) for 3-8 implementation concerns.
> Only use multiple H2 sections if feature has distinct phases or 8+ orthogonal concerns.
>
> **Suggested subsections:**
>
> 1. **Data Structures** - Input/output formats with code examples
> 2. **Core Algorithms** - Step-by-step logic with numbered lists
> 3. **Integration Points** - Dependencies and consumers
> 4. **Error Handling** - Validation, edge cases, failure modes
> 5. **Performance Considerations** - Optimization strategies
> 6. **Testing Strategy** - Unit/integration/performance approaches
>
> For algorithms, use **numbered steps** showing execution flow.
> Use pseudocode or actual language syntax for complex logic.
> Reference `research.md` for design rationale - don't duplicate here.

### 1. Data Structures

> [INSTRUCTIONS]
> Show input/output formats with examples in target language syntax.

### 2. Core Algorithms

> [INSTRUCTIONS]
> Numbered steps showing execution order with logic, conditions, loops, transformations.

### 3. Integration Points

> [INSTRUCTIONS]
> **Consumed by:** List features that use this feature's outputs.
> **Depends on:** List features this depends on.

### 4. Error Handling

> [INSTRUCTIONS]
> Define failure scenarios, validation rules, edge cases, error responses, and graceful degradation strategies.

### 5. Performance Considerations

> [INSTRUCTIONS]
> Document optimization strategies (caching, algorithm efficiency, data structures) and measurable performance targets.

### 6. Testing Strategy

> [INSTRUCTIONS]
> Define unit tests (key scenarios, edge cases), integration tests (end-to-end workflows), performance tests (benchmarks), and coverage targets.

---

## Usage Examples

> [INSTRUCTIONS]
> Show 2 examples: (1) Basic usage with minimal parameters, (2) Integration pattern showing how other features consume this. Use actual code syntax for target technology.
