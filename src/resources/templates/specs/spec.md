---
id: [feature-id]
title: [feature-name]
author: [product-manager]
description: "This document defines the what and why of the {feature-name} feature for architects and engineers. The document is generated by Catalyst AI and reviewed by the feature PM."
dependencies:
  - [list-of-dependent-feature-ids]
---

<!-- markdownlint-disable single-title -->

# Feature: {feature-name}

> [INSTRUCTIONS]
> Think deeply about the requested feature and fill out the sections of this specification autonomously. If market analysis or a competitive analysis exist in the `.xe/features/{feature-id}` folder, use them to inform the feature requirements to make the feature competitive in the market. Follow instructions in each `> [INSTRUCTIONS]` block and remove the instructions when complete. Focus on WHAT users need and WHY. Avoid HOW to implement (no tech stack, APIs, code structure). This document is written for business stakeholders, not developers.
>
> **Living Specification**: Define desired outcome as if implementing from scratch. Do not reference previous state or optimization goals.
>
> **CRITICAL - Avoid Circular Dependencies**: Only reference features this feature depends on (listed in frontmatter dependencies). Never mention features that will depend on this feature.

## Problem

> [INSTRUCTIONS]
> 1-2 sentences explaining WHY this feature is needed.

## Goals

> [INSTRUCTIONS]
> 1-3 high-level, aspirational outcomes defining WHAT we want to achieve, not HOW.

Explicit non-goals:

> [INSTRUCTIONS]
> 0-2 goals this feature _won't_ cover. Only list goals to clarify confusion. Do not list obvious non-goals. Remove list if empty.

## Scenario

> [INSTRUCTIONS]
> List of user stories and outcomes. User stories must be formatted as `As a {persona}, I need to {action-to-perform} so that {goal-or-value-prop}`. Include a nested bullet with the expected outcome to define what must be measurably better with this feature, using an `Outcome:` prefix for clarity.

## Success Criteria

> [INSTRUCTIONS]
> 1-5 SMART metrics indicating long-term success (not spec implementation). Each defines HOW we measure achievement after requirements are implemented.

## Design principles

> [INSTRUCTIONS]
> 0-5 high-level, non-negotiable values to guide decisions specific to this feature. This extends product-wide principles. Each should have a short name and detailed description. Remove if none. Design principles must:
>
> - Begin with a short, imperative phrase that reflects a clear design priority (e.g., “Lead with autonomy”, “Favor reversibility”, “Default to traceability”).
> - Principles should be memorable and directive—suitable for headers or spec tags
> - Use declarative statements, not suggestions or instructions (e.g., “Design for graceful degradation” instead of “Handle errors gracefully”).
> - Reflect a value or tradeoff that guides design decisions (e.g., “Favor clarity over brevity” implies a prioritization).
> - Ensure principles are enduring, not tied to specific tech or implementation (e.g., “Fail loud when assumptions are violated” applies across platforms).
> - Avoid generic or vague phrases like “Be user-friendly” or “Use best practices”. (These lack specificity and don’t guide actual decisions.)
> - Prefer imperative phrasing that starts with a verb or strong tone (e.g., “Design for trust over automation speed” or “Default to explicit behavior”).
> - Express a tradeoff or constraint that guides implementation decisions (e.g., autonomy vs. oversight, speed vs. safety).
> - Include a brief rationale (1–2 sentences) that clarifies scope, boundaries, and intended behavior.
> - Prioritize principles that are actionable, opinionated, and enduring across use cases.
> - Optionally include a short rationale (1–2 sentences) after each principle to clarify intent without diluting the principle itself. Use the quote (`>`) markdown format for the description. Rationale should clarify when the principle applies, what it enables, and what it constrains
>
> All generated assets (e.g., code, documentation) for this feature should reflect these design principles in structure, tone, and behavior.
>
> Design principles are effectively constraints and inspiration to reduce friction and streamline decision-making when debating multiple approaches. If you find you are debating a philosophical approach and not coming to a conclusion easily, it is very likely you are missing a foundational design principle that could streamline those types of decisions.
>
> Design principles are intended to be maintained over time. They are not required but encouraged for multi-person teams and highly recommended for larger teams.

## Requirements

> [INSTRUCTIONS]
> Functional and non-functional requirements specifying WHAT the system MUST do (not HOW to implement). Must be concrete, testable specifications written as verifiable MUST/SHOULD/MAY statements.
>
> **ID Format:** `- **{TYPE}:{path}**: Description` where TYPE is FR/NFR/REQ, path is dot-separated kebab-case.
> **Severity:** Add 1-5 severity to indicate importance:
>
> - `S1` (Critical): Core functionality, security, data integrity - MUST have code + tests
> - `S2` (Important): Key features, error handling, integration points - MUST have code
> - `S3` (Standard): Regular functionality, validation, formatting - SHOULD have code (default if not specified)
> - `S4` (Minor): Convenience features, optimizations, edge cases - MAY have code
> - `S5` (Informational): Documentation, process, non-code deliverables - No code tracing expected
>
> **State:** `[deprecated: FR:new.path]` if superseded (use strikethrough: `~~**FR:old**~~`)
>
> ```markdown
> - **FR:auth.token**: Token session management
>   - **FR:auth.token.expiry** (S1): Sessions MUST expire after 90 minutes
>   - **FR:auth.token.refresh**: Sessions MAY be refreshed
> - ~~**FR:auth.cookie**~~: [deprecated: FR:auth.session] Old auth system
> ```
>
> If requirements are unclear, think about alternatives (pros/cons, risks, irreversible actions) and select a reversible approach that maximizes goals without reducing quality. **DO NOT** select an approach that cannot be reversed.
>
> Include:
>
> - Hard or preferred tech requirements (languages, frameworks, tools, etc) with justification
> - UI and API contracts (inputs/outputs) for user-facing interfaces
>   - Define API in nested code block as first sub-requirement for classes/interfaces
>   - Do not implement full code; only include object or function interfaces with inputs/outputs
> - Behaviors, constraints, business logic/rules (e.g., algorithms, fallback logic), and assumptions (e.g. environment config, installed tools, user knowledge)
> - User types and permissions
> - Data retention/deletion policies
> - Performance targets and scale
> - Error handling behaviors
> - Security/compliance needs

### Functional Requirements

> [INSTRUCTIONS]
> Examples: System MUST [capability], Users MUST be able to [interaction], System MUST [behavior]

### Non-functional requirements

> [INSTRUCTIONS]
> Organize under these standard categories (delete categories not applicable to this feature):
>
> - **NFR:docs**: Documentation (as needed)
>   - Internal docs in `docs-wiki/`
>     - Developer setup
>     - Feature onboarding
>     - Maintenance how-to guides
>   - Public docs in `docs/`
>     - Target audience (developers, end users, admins, etc.)
>     - Documentation deliverables (guides, API reference, examples, troubleshooting, etc.)
>     - Documentation format and location
>     - Code examples and sample usage
>     - Maintenance and update requirements
> - **NFR:cost**: Cost & usage efficiency
> - **NFR:reliability**: Reliability
> - **NFR:performance**: Performance
> - **NFR:observability**: Observability
> - **NFR:auditability**: Auditability
> - **NFR:testability**: Testability
> - **NFR:security**: Security
> - **NFR:accessibility**: Accessibility
> - **NFR:globalization**: Globalization
> - **NFR:compatibility**: Backward compatibility
>
> Each NFR should describe specific, measurable constraints or quality attributes.

## Key Entities

> [INSTRUCTIONS]
> If the feature involves data, describe the entities in this section. Separate entities that are owned by this feature (and must be implemented) and entities referenced from other features. If none, remove section.

Entities owned by this feature:

- **[Entity 1]**: [What it represents, key attributes without implementation]

Entities from other features:

- **[Entity 2]** ([entity-feature-id]): [What it represents, source feature in parentheses]

Inputs:

> [INSTRUCTIONS]
> List of expected inputs (e.g., data types, formats, sources). Use structured examples (e.g., JSON, external standards) where applicable. Include assumptions about end user environment pre-configuration or the inputs themselves.

Outputs:

> [INSTRUCTIONS]
> List of expected outputs (e.g., UI changes, API responses, file formats). Use structured examples (e.g., mockups, JSON) where applicable. Include any assumptions pertaining to the output and what may be needed by the end user in order to take full advantage of the output.

## Dependencies

> [INSTRUCTIONS]
> List dependencies that THIS feature requires to function.
>
> **Internal Dependencies:** Features this feature depends on (must be in front matter dependencies list)
>
> - **[feature-id]**: Brief description of what this feature uses from that dependency
>
> **External Dependencies:** External tools, libraries, or frameworks required (only if explicitly required, do not include implementation decisions)
>
> - **[Tool/Library Name]**: Version requirements and what it's used for
>
> **CRITICAL - Avoid Circular Dependencies:**
>
> - ONLY list features THIS feature depends on (incoming dependencies)
> - NEVER list features that depend on this feature (outgoing/reverse dependencies introduce circular dependencies)
