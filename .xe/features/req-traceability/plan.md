---
id: req-traceability
title: Requirement Traceability
author: "@flanakin"
description: "This document defines the implementation plan for the Requirement Traceability feature for engineers. The document is generated by Catalyst AI and reviewed by the feature architect."
dependencies: []
---

<!-- markdownlint-disable single-title -->

# Implementation Plan: Requirement Traceability

**Spec**: [Feature spec](./spec.md)

---

## Summary

The Requirement Traceability feature provides bidirectional linking between requirements defined in spec files and their implementations in code/tests. A scanner extracts `@req` annotations from source files and requirement definitions from spec.md files, then generates coverage reports showing implementation and test coverage percentages. The feature uses regex-based scanning (no AST parsing) for language-agnostic operation and outputs both JSON reports for programmatic consumption and terminal summaries for human review.

**Design rationale**: See [research.md](./research.md) for analysis of industry patterns, ID format decisions, and annotation strategies.

---

## Technical Context

This feature implementation plan extends the technical architecture defined in `.xe/architecture.md`.

**Feature-specific technical details:**

- **Primary Components**: SpecParser (extracts requirements from markdown), CodeScanner (extracts annotations from source), CoverageAnalyzer (compares and reports), ReportGenerator (JSON + terminal output)
- **Data Structures**: `RequirementId`, `RequirementState`, `RequirementAnnotation`, `TraceabilityReport`, `CoverageStatus`
- **Dependencies**: None (standalone feature); integrates with `catalyst-cli` for CLI commands
- **Configuration**: `.xe/config/catalyst.json` for thresholds and exclude patterns
- **Performance Goals**: <5 seconds for 50K LOC, <100MB memory
- **Testing Framework**: Jest with >90% coverage
- **Key Constraints**: Language-agnostic (regex only, no AST), stable `@req` format as permanent contract

---

## Project Structure

```text
src/
  traceability/
    types/
      index.ts                  # Type exports
      requirement.ts            # RequirementId, RequirementState, RequirementDefinition
      annotation.ts             # RequirementAnnotation, AnnotationLocation
      report.ts                 # TraceabilityReport, CoverageSummary, CoverageStatus
    parsers/
      spec-parser.ts            # Parse spec.md files for requirement definitions
      annotation-scanner.ts     # Scan source files for @req annotations
      task-parser.ts            # Parse tasks.md files for @req references
    analysis/
      coverage-analyzer.ts      # Compare specs vs annotations, compute coverage
    reports/
      json-reporter.ts          # Generate JSON report
      terminal-reporter.ts      # Generate terminal summary
    config/
      traceability-config.ts    # Configuration loading and defaults
    index.ts                    # Public API exports
tests/
  unit/
    traceability/
      parsers/                  # Parser unit tests
      analysis/                 # Analyzer unit tests
      reports/                  # Reporter unit tests
  integration/
    traceability/               # End-to-end scanning tests
  fixtures/
    traceability/
      specs/                    # Sample spec files
      sources/                  # Sample source files with annotations
```

---

## Data Model

**Entities owned by this feature:**

- **RequirementId**: Parsed requirement identifier
  - `type`: 'FR' | 'NFR' | 'REQ'
  - `scope`: string (feature/initiative ID, empty for short-form)
  - `path`: string (dot-separated hierarchy)
  - `qualified`: string (full `{TYPE}:{scope}/{path}` form)
  - `short`: string (short `{TYPE}:{path}` form)

- **RequirementState**: Lifecycle state enum
  - Values: 'active', 'deferred', 'deprecated'

- **RequirementDefinition**: Requirement extracted from spec
  - `id`: RequirementId
  - `state`: RequirementState
  - `text`: string (full requirement text)
  - `specFile`: string (file path)
  - `specLine`: number (line number)
  - `deprecatedTarget`: string | undefined (replacement ID if deprecated)

- **RequirementAnnotation**: Code annotation location
  - `id`: RequirementId
  - `file`: string (source file path)
  - `line`: number (line number)
  - `isPartial`: boolean (uses @req:partial)
  - `isTest`: boolean (in test directory)

- **TaskReference**: Task with requirement references
  - `taskId`: string (e.g., 'T003')
  - `file`: string (tasks.md file path)
  - `line`: number (line number)
  - `description`: string (task description)
  - `requirements`: RequirementId[] (referenced requirements)

- **CoverageStatus**: Derived implementation status
  - Values: 'missing', 'implemented', 'implemented-partial', 'tested', 'deferred', 'deprecated'

- **TraceabilityReport**: Complete analysis output
  - `metadata`: { scanTime, filesScanned, scanDurationMs }
  - `requirements`: Map<string, RequirementCoverage>
  - `orphaned`: OrphanedAnnotation[]
  - `tasks`: Map<string, TaskReference>
  - `summary`: CoverageSummary (includes taskCoverage, tasksWithoutRequirements)

**Entities from other features:**

- None (standalone feature)

---

## Contracts

### SpecParser Class

**Signature:**

```typescript
class SpecParser {
  parseFile(filePath: string): Promise<RequirementDefinition[]>;
  parseDirectory(dirPath: string): Promise<RequirementDefinition[]>;
}
```

**Purpose:** Extract requirement definitions from spec.md files

**Parameters:**

- `filePath` (string): Path to single spec.md file
- `dirPath` (string): Path to directory containing spec.md files (e.g., `.xe/features/`)

**Returns:** Array of `RequirementDefinition` objects with ID, state, text, and location

**Errors/Exceptions:** Returns partial results with warnings for malformed specs (does not throw)

### AnnotationScanner Class

**Signature:**

```typescript
class AnnotationScanner {
  scanFile(filePath: string, isTest: boolean): Promise<RequirementAnnotation[]>;
  scanDirectory(dirPath: string, options: ScanOptions): Promise<RequirementAnnotation[]>;
}
```

**Purpose:** Extract `@req` annotations from source code files

**Parameters:**

- `filePath` (string): Path to single source file
- `dirPath` (string): Path to directory to scan recursively
- `options` (ScanOptions): { exclude: string[], testDirs: string[], respectGitignore: boolean }

**Returns:** Array of `RequirementAnnotation` objects with ID, location, and flags

### TaskParser Class

**Signature:**

```typescript
class TaskParser {
  parseFile(filePath: string): Promise<TaskReference[]>;
  parseDirectory(dirPath: string): Promise<TaskReference[]>;
}
```

**Purpose:** Extract task definitions and their @req references from tasks.md files

**Parameters:**

- `filePath` (string): Path to single tasks.md file
- `dirPath` (string): Path to directory containing tasks.md files (e.g., `.xe/features/`)

**Returns:** Array of `TaskReference` objects with task ID, description, and requirement references

### CoverageAnalyzer Class

**Signature:**

```typescript
class CoverageAnalyzer {
  analyze(
    requirements: RequirementDefinition[],
    annotations: RequirementAnnotation[],
    tasks?: TaskReference[]
  ): TraceabilityReport;
}
```

**Purpose:** Compare requirements against annotations and tasks, compute coverage

**Parameters:**

- `requirements` (RequirementDefinition[]): All requirements from specs
- `annotations` (RequirementAnnotation[]): All annotations from code/tests
- `tasks` (TaskReference[]): Optional task references from tasks.md files

**Returns:** `TraceabilityReport` with per-requirement status, orphans, task mapping, and summary statistics

### ReportGenerator Functions

**Signature:**

```typescript
function generateJsonReport(report: TraceabilityReport): string;
function generateTerminalReport(report: TraceabilityReport): string;
```

**Purpose:** Format traceability report for output

**Returns:** Formatted string (JSON or terminal-friendly text)

---

## Implementation Approach

### 1. Requirement ID Parsing

Parse requirement IDs from both spec files (short-form) and code annotations (qualified form):

**Regex pattern for spec files:**

```typescript
// Matches: **FR:path.to.req**: or ~~**FR:path**~~: [deprecated: FR:new]
const SPEC_REQ_PATTERN = /(?:~~)?\*\*([A-Z]+):([a-z0-9.-]+)\*\*(?:~~)?:\s*(?:\[([a-z]+)(?::\s*([A-Z]+:[a-z0-9./-]+))?\])?\s*(.+)/;
```

**Regex pattern for code annotations:**

```typescript
// Matches: @req FR:scope/path.to.req or @req:partial FR:scope/path
const CODE_REQ_PATTERN = /@req(?::partial)?\s+([A-Z]+):([a-z0-9-]+)\/([a-z0-9.-]+)/g;
```

**ID construction:**

1. Parse type, scope, path components
2. For spec IDs: scope is derived from directory (e.g., `.xe/features/auth/` → scope: `auth`)
3. Build qualified form: `{type}:{scope}/{path}`
4. Build short form: `{type}:{path}`

### 2. Spec Parser Implementation

**parseFile(filePath) algorithm:**

1. Read file content as UTF-8
2. Extract feature/initiative scope from directory path
3. Split into lines, track line numbers
4. For each line matching `SPEC_REQ_PATTERN`:
   - Extract type, path, state marker, deprecated target, description
   - Default state to 'active' if no marker
   - Build RequirementDefinition with full context
5. Return array of definitions

**parseDirectory(dirPath) algorithm:**

1. Glob for `*/spec.md` files in directory
2. For each file, call parseFile()
3. Concatenate results
4. Return combined array

### 3. Annotation Scanner Implementation

**scanFile(filePath, isTest) algorithm:**

1. Read file content as UTF-8
2. Split into lines, track line numbers
3. For each line:
   - Match against `CODE_REQ_PATTERN` (handles multiple per line)
   - For each match, create RequirementAnnotation
   - Set `isPartial` if `@req:partial` prefix
   - Set `isTest` from parameter
4. Return array of annotations

**scanDirectory(dirPath, options) algorithm:**

1. Build glob pattern excluding `options.exclude` patterns
2. If `options.respectGitignore`, parse `.gitignore` and add to exclusions
3. Glob for all files (language-agnostic)
4. For each file:
   - Determine if test file (path contains testDirs pattern)
   - Call scanFile()
5. Concatenate and return results

### 4. Task Parser Implementation

**Regex pattern for tasks:**

```typescript
// Matches: - [ ] T001: Description or - [x] T001: [P] Description
const TASK_PATTERN = /^-\s*\[[ x]\]\s*(T\d+):\s*(?:\[P\]\s*)?(.+)/;
// Matches: @req FR:path (short-form) or @req FR:scope/path (qualified)
const TASK_REQ_PATTERN = /@req\s+([A-Z]+):([a-z0-9./-]+)/;
```

**parseFile(filePath) algorithm:**

1. Read file content as UTF-8
2. Extract feature scope from directory path (e.g., `.xe/features/auth/` → `auth`)
3. Split into lines, track line numbers
4. For each line matching `TASK_PATTERN`:
   - Extract task ID and description
   - Look for @req references in subsequent indented lines (one per line)
   - For each @req: if no `/` in path, prepend current feature scope
   - Build TaskReference with fully-qualified requirements array
5. Return array of task references

**parseDirectory(dirPath) algorithm:**

1. Glob for `*/tasks.md` files in directory
2. For each file, call parseFile()
3. Concatenate results
4. Return combined array

### 5. Coverage Analysis

**analyze(requirements, annotations, tasks) algorithm:**

1. Build map of requirement ID → RequirementDefinition
2. Build map of requirement ID → annotations[]
3. Build map of requirement ID → tasks[] (for task coverage)
4. For each requirement:
   - If state is 'deferred' or 'deprecated', set status accordingly
   - Else if no annotations, status = 'missing'
   - Else if all annotations are partial, status = 'implemented-partial'
   - Else if any test annotation, status = 'tested'
   - Else status = 'implemented'
5. Find orphaned annotations (ID not in requirements map)
6. Build task mapping with requirement references
7. Find tasks without @req references (untracked work)
8. Compute summary:
   - Count active requirements (excluding deferred/deprecated)
   - Count implemented (status in ['implemented', 'implemented-partial', 'tested'])
   - Count tested (status = 'tested')
   - Count planned (has task reference)
   - Count tasks without requirements
   - Compute percentages for all coverage types

### 6. Integration Points

**Consumed by:**

- `catalyst-cli` feature (provides CLI commands)
- Build systems (CI integration)
- Future: VSCode extension, GitHub Action

**Depends on:**

- None (standalone)

### 7. Error Handling

1. **Malformed spec files**: Log warning, skip malformed line, continue parsing
2. **Unreadable files**: Log error with path, continue to next file
3. **Invalid requirement IDs**: Log warning with location, skip annotation
4. **Missing directories**: Return empty array (not an error)

### 8. Performance Considerations

1. **Parallel file reading**: Use Promise.all for concurrent I/O
2. **Compiled regex**: Pre-compile patterns once at module load
3. **Stream processing**: Don't load entire directory tree into memory
4. **Early termination**: Skip binary files by checking first bytes
5. **Caching**: Cache parsed specs during single scan run

### 9. Testing Strategy

**Unit Tests:**

1. **ID parsing tests**: Valid IDs, edge cases, invalid formats
2. **Spec parser tests**: Single requirements, nested, states, deprecated with targets
3. **Annotation scanner tests**: Single-line, block, multi-line, partial, comma-separated
4. **Task parser tests**: Task extraction, @req references, tasks without requirements
5. **Coverage analyzer tests**: All status transitions, orphan detection, task coverage, summary math

**Integration Tests:**

1. **Full scan workflow**: Spec files → annotations → report
2. **Multi-language**: TypeScript, Python, Go annotation samples
3. **Edge cases**: Empty specs, no annotations, 100% coverage, 0% coverage

**Performance Tests:**

1. Scan 50K LOC synthetic codebase in <5 seconds
2. Memory usage <100MB during scan

### 10. Documentation Plan

**Target Audience:** Developers adopting traceability in their projects

**Documentation Type:** User guide with examples

**File Location:** `docs/traceability.md`

**Content Outline:**

1. Overview and benefits
2. ID format specification
3. Annotation syntax (all languages)
4. Configuration options
5. CLI usage
6. Interpreting reports
7. Best practices

**Code Examples:**

- Basic annotation in TypeScript
- JSDoc block annotation
- Python annotation
- Test annotation
- Partial implementation

---

## Usage Examples

### Basic Usage: Annotating Code

```typescript
// @req FR:auth/sessions.lifecycle.expiry
function checkSessionExpiry(session: Session): boolean {
  const maxAge = 90 * 60 * 1000; // 90 minutes
  return Date.now() - session.createdAt > maxAge;
}

// @req FR:auth/sessions.lifecycle.inactivity
// @req FR:auth/sessions.security.validation
async function validateSession(sessionId: string): Promise<Session | null> {
  // Implementation...
}
```

### Integration Pattern: Running Analysis

```typescript
import { SpecParser, AnnotationScanner, TaskParser, CoverageAnalyzer, generateJsonReport } from '@catalyst/traceability';

// Parse all specs
const specParser = new SpecParser();
const requirements = await specParser.parseDirectory('.xe/features/');

// Scan source code
const scanner = new AnnotationScanner();
const annotations = await scanner.scanDirectory('src/', {
  exclude: ['**/node_modules/**', '**/dist/**'],
  testDirs: ['tests/', '__tests__/'],
  respectGitignore: true
});

// Parse tasks (optional)
const taskParser = new TaskParser();
const tasks = await taskParser.parseDirectory('.xe/features/');

// Analyze coverage
const analyzer = new CoverageAnalyzer();
const report = analyzer.analyze(requirements, annotations, tasks);

// Output
console.log(generateTerminalReport(report));
await fs.writeFile('traceability-report.json', generateJsonReport(report));
```
