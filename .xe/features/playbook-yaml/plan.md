---
id: playbook-yaml
title: Playbook YAML Format
author: "@flanakin"
description: "This document defines the implementation plan for the Playbook YAML Format feature for engineers. The document is generated by Catalyst AI and reviewed by the feature architect."
dependencies:
  - playbook-definition
---

<!-- markdownlint-disable single-title -->

# Implementation Plan: Playbook YAML Format

> [CRITICAL INSTRUCTION]
> This implementation plan describes the full implementation of the feature **from scratch**, as if no code exists. Do NOT write this as an enhancement or modification to existing code. Use language like "Create", "Implement", "Build" - NOT "Modify", "Add to", "Update".

**Spec**: [Feature spec](./spec.md)

---

## Summary

The Playbook YAML Format feature provides a declarative YAML syntax for authoring playbooks that transforms to TypeScript interfaces from playbook-definition. The feature includes JSON Schema for IDE IntelliSense, a PlaybookLoader for parsing and validation, and playbook discovery from package and custom directories. The YAML format uses action-type-as-property-key pattern for concise syntax and supports type-as-key for inputs and validation rules.

**Design rationale**: See [research.md](./research.md) for analysis of YAML syntax patterns, JSON Schema approach with `oneOf`, and transformation strategies.

---

## Technical Context

This feature implementation plan extends the technical architecture defined in `.xe/architecture.md`.

**Feature-specific technical details:**

- **Primary Components**: YAML parser/transformer, JSON Schema validator, playbook loader, discovery service
- **Data Structures**: YAML playbook format (source), Playbook interface (target), transformation metadata
- **Dependencies**: `playbook-definition` (target interfaces), `js-yaml` (parsing), `ajv` (schema validation)
- **Configuration**: Schema published at HTTPS URL, playbooks in `playbooks/` and `.xe/playbooks/` directories
- **Performance Goals**: Schema validation <50ms for <100 steps, transformation <100ms total, discovery <500ms for <500 playbooks
- **Testing Framework**: Jest with unit tests for transformation, integration tests for end-to-end loading
- **Key Constraints**: YAML is declarative wrapper over TypeScript interfaces, engine never imports playbook-yaml

---

## Project Structure

```text
src/
  playbooks/
    scripts/
      playbooks/
        yaml/
          parser.ts               # YAML parsing using js-yaml
          transformer.ts          # YAML → Playbook transformation
          validator.ts            # JSON Schema validation using ajv
          loader.ts               # PlaybookLoader class
          discovery.ts            # Playbook file discovery
          # Note: schema.json generated to dist/playbooks/schema.json (build artifact)
tests/
  unit/
    playbooks/
      yaml/
        parser.test.ts           # YAML parsing tests
        transformer.test.ts      # Transformation tests
        validator.test.ts        # Schema validation tests
  integration/
    playbooks/
      yaml/
        loader.test.ts           # End-to-end loading tests
  fixtures/
    playbooks/
      valid-minimal.yaml         # Minimal valid playbook
      valid-complete.yaml        # All optional properties
      invalid-syntax.yaml        # YAML syntax errors
      invalid-schema.yaml        # Schema violations
      edge-cases.yaml            # Transformation edge cases
```

---

## Data Model

**Entities owned by this feature:**

- **YAML Playbook Format**: Declarative syntax for authoring playbooks
  - Top-level properties: `name`, `description`, `owner`, `steps` (required)
  - Optional: `reviewers`, `triggers`, `inputs`, `outputs`, `catch`, `finally`
  - Uses action-type-as-property-key pattern in steps
  - Uses type-as-key pattern for inputs and validation rules

- **PlaybookYAMLSchema**: JSON Schema for validation and IDE support
  - Defines valid playbook structure using `oneOf` for actions
  - Enforces exactly one action per step at schema validation time
  - Includes `custom-action` variant for extensibility
  - Published at HTTPS URL for IDE IntelliSense

- **PlaybookLoader**: Service for loading YAML playbooks
  - `load(yamlPath: string): Promise<Playbook>` - Load from file
  - `loadFromString(yamlContent: string): Promise<Playbook>` - Load from string
  - Parses YAML, validates against schema, transforms to Playbook interface
  - Throws ValidationError with line numbers on failure

- **PlaybookDiscovery**: Service for finding playbook files
  - Scans `playbooks/` (package) and `.xe/playbooks/` (custom) directories
  - Filters for `.yaml` extension
  - Returns playbook paths for lazy loading

**Entities from other features:**

- **Playbook, PlaybookStep, InputParameter** (playbook-definition): Target TypeScript interfaces
- **InputValidationRule** (playbook-definition): Validation rule types for transformation

---

## Contracts

### PlaybookLoader Interface

**Signature:**

```typescript
interface PlaybookLoader {
  load(yamlPath: string): Promise<Playbook>;
  loadFromString(yamlContent: string): Promise<Playbook>;
}
```

**Purpose:** Load and transform YAML playbooks to TypeScript Playbook interface

**Methods:**

- `load`: Read YAML file, validate, transform to Playbook
- `loadFromString`: Parse YAML string, validate, transform to Playbook

**Errors/Exceptions:**

- `ValidationError`: YAML syntax errors, schema validation failures, transformation errors
- Includes file path, line/column numbers, property paths
- Provides actionable guidance for fixing errors

**Examples:**

```typescript
const loader = new PlaybookLoader();
const playbook = await loader.load('playbooks/my-playbook.yaml');
```

### PlaybookDiscovery Interface

**Signature:**

```typescript
interface PlaybookDiscovery {
  discover(): Promise<string[]>;
}
```

**Purpose:** Find all playbook YAML files in package and custom directories

**Returns:** Array of absolute file paths to `.yaml` playbook files

**Performance:** Completes in <500ms for <500 playbooks (glob only, no parsing)

---

## Implementation Approach

### 1. JSON Schema Generation

Generate JSON Schema during build directly to `dist/playbooks/schema.json`:

**Generation approach:**
1. Create schema generation script `scripts/generate-playbook-schema.ts`
2. Import ACTION_REGISTRY from playbook-definition
3. Build schema programmatically:
   - Define required top-level properties (`name`, `description`, `owner`, `steps`)
   - Define optional properties with proper types and constraints
   - Generate `oneOf` array for step validation by iterating ACTION_REGISTRY
   - For each action with `configSchema`: Create step variant requiring that action key
   - Incorporate action's configSchema properties into step definition
   - Support primary property pattern (value can be string or object with configSchema properties)
   - Add `custom-action` variant for extensibility
   - Support type-as-key pattern for inputs using property pattern matching
   - Support validation type properties in validation arrays
4. Write generated schema directly to `dist/playbooks/schema.json` (simpler path, next to playbooks)
5. Integrate into build process: Run after TypeScript compilation and file copying (so dist/ exists)
6. Schema.json is a build artifact (NOT in src/, only in dist/)
7. Validator loads from `require.resolve('@xerilium/catalyst/playbooks/schema.json')` (always from node_modules)
8. Build copies dist → node_modules, making schema available at consistent path for both dev and prod

**Key schema patterns:**
- Step: `oneOf` array with variant for each action in ACTION_REGISTRY plus `custom-action`
- Action value: `oneOf` allowing primary property (string, number, boolean, etc.) OR object with configSchema properties
- Input: Properties matching `string`, `number`, `boolean` as type indicators
- Validation: Properties matching `regex`, `minLength`, `maxLength`, `min`, `max`, `script`

**Benefits:**
- Schema automatically stays in sync with ACTION_REGISTRY on every build
- IDE IntelliSense includes actual config properties from action configSchema
- Config property descriptions from JSDoc appear in IDE tooltips
- No manual maintenance required (DRY principle)
- No git churn from generated files

### 2. YAML Parser

Implement YAML parsing in `src/playbooks/scripts/playbooks/yaml/parser.ts`:

**Implementation approach:**
1. Use `js-yaml` library for parsing
2. Configure for safe loading (no arbitrary code execution)
3. Capture parsing errors with line/column numbers
4. Return parsed object or throw with detailed error message

### 3. Schema Validator

Implement schema validation in `src/playbooks/scripts/playbooks/yaml/validator.ts`:

**Implementation approach:**
1. Use `ajv` library for JSON Schema validation
2. Load generated schema from `require.resolve('@xerilium/catalyst/playbooks/schema.json')` at module initialization
3. Pre-compile schema (cache compiled validator)
4. Validate parsed YAML object against schema
5. Convert ajv errors to readable format with property paths
6. Return validation result with errors array

### 4. YAML Transformer

Implement transformation in `src/playbooks/scripts/playbooks/yaml/transformer.ts`:

**Step transformation approach:**
1. Identify action type by finding non-reserved property key (not `name`, `errorPolicy`)
2. Extract action value and additional properties
3. Lookup action in ACTION_REGISTRY (imported from playbook-definition)
4. Build `config` based on action value and registry:
   - **Pattern 1 (No inputs)**: Null/undefined → Use only additional properties
   - **Pattern 2 (Primary property)**: Non-null value AND primaryProperty in registry → Map value to primary property, merge additional properties
   - **Pattern 3 (Object-only)**: Object value AND no primaryProperty in registry → Use object as-is, merge additional properties
5. Construct PlaybookStep with `action`, `config`, optional `name` and `errorPolicy`

**Note**: Primary property value can be any type (string, number, boolean, array, or object), not just primitives.

**Input transformation approach:**
1. Find type property key (`string`, `number`, `boolean`)
2. Extract parameter name from type property value
3. Map remaining properties to InputParameter interface
4. Transform validation array if present

**Validation transformation approach:**
1. Detect validation type from property keys
2. Map to appropriate ValidationRule interface with type discriminator
3. Preserve optional `code` and `message` properties

### 5. Playbook Loader

Implement loader in `src/playbooks/scripts/playbooks/yaml/loader.ts`:

**load(yamlPath) approach:**
1. Read file content as UTF-8
2. Parse YAML using parser
3. Validate against schema using validator
4. Transform to Playbook interface using transformer
5. On error, throw ValidationError with file path and details

**loadFromString(yamlContent) approach:**
1. Parse YAML string using parser
2. Validate against schema using validator
3. Transform to Playbook interface using transformer
4. On error, throw ValidationError with content snippet and details

### 6. Playbook Discovery

Implement discovery in `src/playbooks/scripts/playbooks/yaml/discovery.ts`:

**Implementation approach:**
1. Define search paths: `playbooks/` and `.xe/playbooks/`
2. Use glob pattern `**/*.yaml` for each directory
3. Resolve absolute paths
4. Filter duplicates if same file appears in both
5. Return sorted array of paths
6. Handle missing directories gracefully (return empty for that path)

### 7. Error Handling

Define error scenarios and messages:

1. **YAML syntax errors**:
   - Include line and column numbers from js-yaml
   - Show snippet of problematic line
   - Suggest common fixes (indentation, quotes, colons)

2. **Schema validation errors**:
   - Map ajv property paths to readable format
   - Show expected vs actual type
   - Reference spec requirement that failed

3. **Transformation errors**:
   - Indicate step index or property path
   - Explain what's missing or malformed
   - Provide example of correct syntax

### 8. Testing Strategy

**Unit Tests:**

1. **Schema generation tests**: Verify schema generation from ACTION_REGISTRY
   - Schema contains all actions from ACTION_REGISTRY with configSchema
   - Each action's configSchema properties appear in schema
   - Actions with primaryProperty support both value and object patterns
   - Custom-action variant exists for extensibility
   - Generated schema is valid JSON Schema draft-07
   - Schema generation completes in <5 seconds
2. **Parser tests**: Valid YAML, syntax errors, empty files, Unicode
3. **Validator tests**: Valid schemas, missing required fields, type mismatches, oneOf enforcement
4. **Transformer tests**: All three value patterns, input parsing, validation parsing, step arrays (main, catch, finally)
5. **Loader tests**: Successful load, file not found, YAML errors, schema errors, transformation errors
6. **Discovery tests**: Find playbooks in both directories, handle missing directories, filter by extension

**Integration Tests:**

1. Load real playbook fixtures end-to-end
2. Verify transformed Playbook matches expected structure
3. Test IDE schema validation (manual)
4. **Schema-to-validator integration**: Verify generated schema works with validator

**Performance Tests:**

1. Schema generation <5 seconds
2. Schema validation <50ms for 100-step playbook
3. Full transformation <100ms
4. Discovery <500ms for 500 playbooks

**Coverage Targets:**

- 100% coverage for schema generation logic
- 100% coverage for transformation edge cases
- 100% coverage for error handling paths
- 95% overall coverage

---

## Usage Examples

### Basic Usage: Loading a Playbook

```typescript
import { PlaybookLoader } from '@catalyst/playbooks/yaml';

const loader = new PlaybookLoader();
const playbook = await loader.load('playbooks/my-workflow.yaml');

console.log(`Loaded playbook: ${playbook.name}`);
console.log(`Steps: ${playbook.steps.length}`);
```

### Integration Pattern: Playbook Discovery

```typescript
import { PlaybookDiscovery } from '@catalyst/playbooks/yaml';

const discovery = new PlaybookDiscovery();
const playbookPaths = await discovery.discover();

for (const path of playbookPaths) {
  const playbook = await loader.load(path);
  console.log(`Found: ${playbook.name}`);
}
```

### Error Handling Example

```typescript
try {
  const playbook = await loader.load('invalid-playbook.yaml');
} catch (err) {
  if (err instanceof ValidationError) {
    console.error(`Validation failed in ${err.filePath}`);
    console.error(`Line ${err.line}, Column ${err.column}: ${err.message}`);
  }
}
```

---

## Documentation

### Customer-Facing Documentation

Create user documentation in `docs/playbooks/yaml-format.md`:

**Content structure:**
1. **Overview**: What is the YAML playbook format and why use it
2. **Getting Started**: Minimal playbook example with explanation
3. **Syntax Reference**:
   - Top-level properties (required and optional)
   - Step syntax with action-type-as-property-key pattern
   - Input parameter syntax with type-as-key pattern
   - Validation rule syntax
   - Error handling (catch/finally)
4. **Action Value Patterns**: Three patterns (primitive, object, null) with examples
5. **IDE Setup**: How to enable IntelliSense in VS Code and other editors
6. **Common Patterns**: Real-world examples (creating issues, managing PRs, CI workflows)
7. **Troubleshooting**: Common errors and how to fix them
8. **Schema Reference**: Link to published JSON Schema URL

**Tone**: Clear, beginner-friendly, example-driven

**Examples**: Include complete, working playbook examples that users can copy

---

## Edge Cases and Considerations

1. **YAML anchors and aliases**: Supported by js-yaml by default, test to ensure they work
2. **Duplicate step names**: Transformation should preserve duplicates, engine validates uniqueness
3. **Empty inputs/outputs arrays**: Transform as empty array, not undefined
4. **Null vs undefined**: YAML `~` is null, omitted is undefined - handle consistently
5. **Large playbooks**: Test with 100+ steps to ensure performance targets met
6. **Invalid UTF-8**: Parser should fail gracefully with encoding error
7. **Circular references**: YAML anchors shouldn't create circular refs, test and document
