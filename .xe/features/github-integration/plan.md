---
id: github-integration
title: GitHub Integration
author: "@flanakin"
description: "This document defines the implementation plan for the GitHub Integration feature for engineers. The document is generated by Catalyst AI and reviewed by the feature architect."
dependencies: []
---

<!-- markdownlint-disable single-title -->

# Implementation Plan: GitHub Integration

**Spec**: [Feature spec](./spec.md)

---

## Summary

The GitHub Integration feature provides a CLI-first wrapper around GitHub operations (issues, PRs, comments, repository settings) with dependency injection for testability. The implementation uses an adapter pattern with a `GitHubClient` interface and `GitHubAdapter` concrete implementation that wraps the `gh` CLI and/or GitHub REST API. The CLI is built using a command routing system that maps intuitive commands like `catalyst-github issue create` to underlying TypeScript functions, with structured error handling that returns explicit error types and actionable remediation guidance. This enables Catalyst playbooks to perform GitHub operations programmatically while maintaining full test coverage through mockable interfaces.

**Design rationale**: See [research.md](./research.md) for analysis of dependency inversion approach, adapter pattern selection, and error handling strategy.

---

## Technical Context

This feature implementation plan extends the technical architecture defined in `.xe/architecture.md`.

**Feature-specific technical details:**

- **Primary Components**: `GitHubClient` interface, `GitHubAdapter` implementation, `catalyst-github` CLI executable, error types, result wrappers
- **Data Structures**: `Result<T>` wrapper type for success/error, `GitHubError` hierarchy, issue/PR/comment DTOs
- **Dependencies**: GitHub CLI (`gh` version 2.0+), Node.js `child_process`, TypeScript runtime
- **Configuration**: No configuration files - relies on `gh` CLI authentication state
- **Performance Goals**: Operations complete <5 seconds, CLI commands return <1 second for non-network operations
- **Testing Framework**: Jest with ts-jest, target 90% code coverage per `.xe/engineering.md`
- **Key Constraints**: Must work with `gh` CLI authentication, must support dependency injection for testing, must maintain backward compatibility with existing `github.ts` usage

---

## Project Structure

```
src/
  playbooks/
    scripts/
      github.ts                  # Main entry point - exports all functions and CLI interface
      github/                    # GitHub integration modules
        types.ts                 # TypeScript types and interfaces
        errors.ts                # Error hierarchy (GitHubError, etc.)
        client.ts                # GitHubClient interface
        adapter.ts               # GitHubAdapter implementation
        cli.ts                   # CLI command parser and router
        mock.ts                  # Mock implementation for testing
  integrations/                  # (Existing - no changes needed)
bin/
  catalyst-github.js             # CLI executable shim (npx entry point)
tests/
  unit/
    github/                      # Unit tests for GitHub integration
      adapter.test.ts            # Adapter tests with mocked execSync
      cli.test.ts                # CLI parser tests
      errors.test.ts             # Error type tests
  integration/
    github/                      # Integration tests (optional - require gh CLI)
      issue-operations.test.ts   # End-to-end issue tests
      pr-operations.test.ts      # End-to-end PR tests
```

---

## Data Model

**Entities owned by this feature:**

- **GitHubClient (Interface)**: Abstract contract for all GitHub operations
  - Methods for issues, PRs, comments, reviews, repository operations
  - Returns `Result<T>` for all operations

- **Result<T>**: Success/error wrapper
  - `success`: boolean - indicates operation success
  - `data`: T | null - operation result if successful
  - `error`: GitHubError | null - error details if failed

- **GitHubError**: Base error class
  - `message`: string - human-readable error description
  - `code`: string - machine-readable error code
  - `remediation`: string - actionable steps to fix the error
  - `cause`: Error | null - underlying error if available

- **GitHubAuthError**: Authentication failure (extends GitHubError)
- **GitHubNotFoundError**: Resource not found (extends GitHubError)
- **GitHubNetworkError**: Network/connectivity failure (extends GitHubError)
- **GitHubRateLimitError**: Rate limit exceeded (extends GitHubError)
- **GitHubPermissionError**: Insufficient permissions (extends GitHubError)

- **Issue**: GitHub issue representation
  - `number`: number - issue number
  - `title`: string - issue title
  - `body`: string - issue description
  - `state`: 'open' | 'closed' - issue state
  - `labels`: string[] - issue labels
  - `comments`: Comment[] - issue comments (optional)

- **PullRequest**: GitHub PR representation
  - `number`: number - PR number
  - `title`: string - PR title
  - `body`: string - PR description
  - `state`: 'open' | 'closed' | 'merged' - PR state
  - `headRef`: string - source branch name
  - `baseRef`: string - target branch name

- **Comment**: Issue/PR comment
  - `id`: number - comment ID
  - `author`: string - comment author username
  - `body`: string - comment text
  - `createdAt`: string - ISO timestamp

- **Thread**: PR review comment thread
  - `threadId`: number - thread identifier
  - `path`: string - file path
  - `line`: number | null - line number
  - `resolved`: boolean - resolution status
  - `comments`: Comment[] - thread comments

**Entities from other features:**

- None (foundation feature with no dependencies)

---

## Contracts

### GitHubClient Interface

**Signature:**

```typescript
interface GitHubClient {
  // Issue operations
  findIssue(pattern: string, repo?: string): Promise<Result<Issue | null>>;
  getIssue(issueNumber: number): Promise<Result<Issue>>;
  getIssueWithComments(issueNumber: number): Promise<Result<Issue>>;
  listIssues(filters: IssueFilters): Promise<Result<Issue[]>>;
  createIssue(title: string, body: string, options?: IssueOptions): Promise<Result<Issue>>;
  updateIssue(issueNumber: number, updates: IssueUpdates): Promise<Result<Issue>>;
  addIssueComment(issueNumber: number, body: string): Promise<Result<Comment>>;
  closeIssue(issueNumber: number, reason?: string): Promise<Result<Issue>>;

  // PR operations
  findPRs(searchPattern: string): Promise<Result<PullRequest[]>>;
  getPR(prNumber: number): Promise<Result<PullRequest>>;
  getPRFeature(prNumber: number): Promise<Result<{ featureId: string | null; branchName: string }>>;
  listPRs(filters: PRFilters): Promise<Result<PullRequest[]>>;
  getPRComments(prNumber: number): Promise<Result<Comment[]>>;
  addPRComment(prNumber: number, body: string): Promise<Result<Comment>>;
  findPRThreads(prNumber: number): Promise<Result<Thread[]>>;
  replyToThread(prNumber: number, threadId: number, body: string): Promise<Result<Comment>>;
  getPRReviews(prNumber: number): Promise<Result<Review[]>>;
  submitPRReview(prNumber: number, status: ReviewStatus, body: string): Promise<Result<Review>>;
  dismissPRReview(prNumber: number, reviewId: number): Promise<Result<void>>;

  // Repository operations
  getRepositoryInfo(): Promise<Result<RepositoryInfo>>;
  setBranchProtection(branch: string, rules: BranchProtectionRules): Promise<Result<void>>;
  createLabel(name: string, color: string, description?: string): Promise<Result<Label>>;
  updateLabel(name: string, updates: LabelUpdates): Promise<Result<Label>>;
  deleteLabel(name: string): Promise<Result<void>>;
  setRepositoryProperties(properties: RepositoryProperties): Promise<Result<void>>;
  setMergeSettings(settings: MergeSettings): Promise<Result<void>>;

  // Authentication
  checkAuth(): Promise<Result<{ authenticated: boolean; username?: string }>>;
  authenticate(install: boolean, force: boolean): Promise<Result<void>>;
}
```

**Purpose:** Abstract contract for all GitHub operations with dependency injection support

### CLI Command Structure

**Signature:**

```bash
catalyst-github <command> [subcommand] [args] [options]
```

**Purpose:** Route CLI commands to GitHubClient methods

**Command Mapping:**

- `issue find <pattern>` → `findIssue(pattern)`
- `issue get <number>` → `getIssue(number)` or `getIssueWithComments(number)` with `--with-comments`
- `issue list` → `listIssues(filters)` with optional `--state`, `--label` flags
- `issue create` → `createIssue(title, body, options)` with `--title`, `--body` flags
- `issue update <number>` → `updateIssue(number, updates)` with optional flags
- `issue comment <number> <body>` → `addIssueComment(number, body)`
- `issue close <number>` → `closeIssue(number, reason)` with optional `--reason`
- `pr find <pattern>` → `findPRs(pattern)`
- `pr get <number>` → `getPR(number)`
- `pr get-feature <number>` → `getPRFeature(number)`
- `pr list` → `listPRs(filters)` with optional flags
- `pr comments <number>` → `getPRComments(number)`
- `pr comment <number> <body>` → `addPRComment(number, body)`
- `pr threads <number>` → `findPRThreads(number)`
- `pr reply <pr-number> <thread-id> <body>` → `replyToThread(pr, thread, body)`
- `pr reviews <number>` → `getPRReviews(number)`
- `pr review <number>` → `submitPRReview(number, status, body)` with `--status` flag
- `pr dismiss-review <pr-number> <review-id>` → `dismissPRReview(pr, review)`
- `repo info` → `getRepositoryInfo()` with optional `--json` flag
- `repo protect <branch>` → `setBranchProtection(branch, rules)` with rule flags
- `repo label create <name>` → `createLabel(name, color, desc)` with `--color` flag
- `auth` → `authenticate(install, force)` with optional `--install`, `--force` flags

**Returns:** JSON for structured data (with `--json` flag), plain text for simple values

**Exit Codes:** 0 on success, non-zero on failure

---

## Implementation Approach

### 1. Type Definitions and Error Hierarchy

Create comprehensive TypeScript types for all GitHub entities and operations.

**Error Hierarchy Implementation:**

1. Define base `GitHubError` class with `message`, `code`, `remediation`, `cause` fields
2. Create specialized error classes extending `GitHubError`:
   - `GitHubAuthError`: code 'AUTH_ERROR', remediation includes `gh auth login` instructions
   - `GitHubNotFoundError`: code 'NOT_FOUND', includes resource type and identifier
   - `GitHubNetworkError`: code 'NETWORK_ERROR', suggests checking connectivity
   - `GitHubRateLimitError`: code 'RATE_LIMIT', includes retry-after timestamp
   - `GitHubPermissionError`: code 'PERMISSION_ERROR', lists required scopes
3. Each error type provides actionable remediation steps specific to failure mode

**Result Wrapper Implementation:**

```typescript
type Result<T> = {
  success: true;
  data: T;
  error: null;
} | {
  success: false;
  data: null;
  error: GitHubError;
};

function success<T>(data: T): Result<T> {
  return { success: true, data, error: null };
}

function failure<T>(error: GitHubError): Result<T> {
  return { success: false, data: null, error };
}
```

### 2. GitHubClient Interface

Define abstract interface for all GitHub operations:

1. Group methods by concern: issues, PRs, repository, auth
2. All methods return `Promise<Result<T>>` for consistent error handling
3. Use TypeScript interfaces for complex parameters (filters, options, updates)
4. Document each method with JSDoc comments including usage examples

### 3. GitHubAdapter Implementation

Implement concrete adapter using `gh` CLI and/or REST API:

**Architecture:**

1. Constructor accepts optional dependencies (for testing):
   ```typescript
   constructor(private execCommand: (cmd: string) => string = execSync)
   ```

2. Private helper methods for common operations:
   - `runCommand(cmd: string): Result<string>` - executes CLI command, catches errors
   - `parseJSON<T>(output: string): Result<T>` - parses JSON with error handling
   - `handleCLIError(error: Error): GitHubError` - maps CLI errors to GitHubError types
   - `getRepository(): Result<{owner: string, name: string}>` - detects current repo

3. Implement each interface method:
   - Call `runCommand()` with appropriate `gh` CLI command
   - Parse JSON output into TypeScript types
   - Map CLI errors to structured `GitHubError` instances
   - Return `Result<T>` with success data or error

**Error Detection Strategy:**

1. Check CLI exit code (non-zero = error)
2. Parse stderr for error messages
3. Match error patterns:
   - "not logged in" → `GitHubAuthError`
   - "not found" / "404" → `GitHubNotFoundError`
   - "rate limit" / "403" → `GitHubRateLimitError`
   - "permission denied" → `GitHubPermissionError`
   - Connection/network errors → `GitHubNetworkError`
   - Unknown → `GitHubError` base class

**Hard-coded Repository Fix:**

1. Replace hard-coded "Xerilium/catalyst" with dynamic detection
2. Use `getRepository()` helper to extract owner/name from git remote or `gh` context
3. Pass repository parameter to all operations requiring it

### 4. CLI Command Parser

Build command routing system:

**Parser Implementation:**

1. Parse `process.argv` to extract command, subcommand, args, flags
2. Route to appropriate handler based on command structure:
   ```typescript
   const commands = {
     issue: {
       find: handleIssueFindCommand,
       get: handleIssueGetCommand,
       list: handleIssueListCommand,
       create: handleIssueCreateCommand,
       // ... more commands
     },
     pr: { /* ... */ },
     repo: { /* ... */ },
     auth: handleAuthCommand,
   };
   ```

3. Each handler:
   - Validates required arguments
   - Parses flags into typed objects
   - Calls corresponding `GitHubClient` method
   - Formats output (JSON or plain text based on flags)
   - Exits with appropriate code

**Output Formatting:**

1. Default: Plain text for human readability
2. `--json` flag: JSON output for script consumption
3. Success data goes to stdout
4. Errors go to stderr with actionable guidance
5. Exit code 0 on success, 1 on error

**Help System:**

1. `--help` flag shows command usage and examples
2. Missing arguments trigger help text
3. Invalid commands suggest correct syntax

### 5. Mock Implementation

Create mock adapter for testing:

**Mock Strategy:**

1. Implement `GitHubClient` interface with in-memory data
2. Store mock data in Maps (issues, PRs, comments)
3. Simulate operations (create, update, delete) on mock data
4. Return predictable results for testing

**Configuration:**

```typescript
class MockGitHubClient implements GitHubClient {
  private issues = new Map<number, Issue>();
  private prs = new Map<number, PullRequest>();

  // Pre-populate with test data
  constructor(seedData?: { issues?: Issue[], prs?: PullRequest[] }) {
    seedData?.issues?.forEach(issue => this.issues.set(issue.number, issue));
    seedData?.prs?.forEach(pr => this.prs.set(pr.number, pr));
  }

  // Implement all interface methods with in-memory operations
  async getIssue(issueNumber: number): Promise<Result<Issue>> {
    const issue = this.issues.get(issueNumber);
    if (!issue) {
      return failure(new GitHubNotFoundError(`Issue #${issueNumber} not found`));
    }
    return success(issue);
  }

  // ... more implementations
}
```

### 6. Integration with Existing Code

Maintain backward compatibility:

**Strategy:**

1. Keep existing `github.ts` exports for backward compatibility
2. Add new exports for `GitHubClient`, `GitHubAdapter`, `Result`, error types
3. Existing functions become thin wrappers around `GitHubAdapter`:
   ```typescript
   export function getIssueBody(issueNumber: string): string | null {
     const adapter = new GitHubAdapter();
     const result = await adapter.getIssue(parseInt(issueNumber));
     if (result.success) {
       return result.data.body;
     }
     console.error(result.error.message);
     return null;
   }
   ```

4. CLI interface at bottom of `github.ts` updated to use new command parser
5. Existing playbook calls to `node github.js --get-issue 123` continue working

### 7. Template Operations

Implement internal template processing functions:

**Implementation:**

1. `readIssueTemplate(templateName: string): Result<string>`:
   - Read file from `templates/issues/{templateName}.md`
   - Return file contents or error if not found

2. `parseTemplateFrontmatter(template: string): { frontmatter: object, body: string }`:
   - Split template into frontmatter (YAML between `---`) and body
   - Parse frontmatter into object with labels, assignees, milestones
   - Return separated frontmatter and body

3. `replaceTemplatePlaceholders(body: string, replacements: Record<string, string>): string`:
   - Replace `{placeholder-name}` with values from replacements object
   - Return processed body

4. `createIssueFromTemplate(templateName: string, replacements: Record<string, string>): Promise<Result<Issue>>`:
   - Read template → parse frontmatter → replace placeholders
   - Call `createIssue()` with metadata from frontmatter and processed body
   - Return issue creation result

**Note:** These are internal functions used by playbooks, not exposed via CLI.

### 8. Repository Settings Operations

Implement repository configuration functions:

**Branch Protection:**

1. `setBranchProtection(branch: string, rules: BranchProtectionRules)`:
   - Map rules object to `gh` CLI flags
   - Call `gh api` to update branch protection via REST API
   - Rules include: requirePR, requiredReviews, requireStatusChecks, etc.

**Label Management:**

1. `createLabel(name: string, color: string, description?: string)`:
   - Call `gh label create {name} --color {color} --description {desc}`
   - Return created label or error if already exists

2. `updateLabel(name: string, updates: LabelUpdates)`:
   - Call `gh label edit {name}` with appropriate flags
   - Return updated label

3. `deleteLabel(name: string)`:
   - Call `gh label delete {name}`
   - Return success or error

**Repository Properties:**

1. `setRepositoryProperties(properties: RepositoryProperties)`:
   - Call `gh repo edit` with flags for description, homepage, topics
   - Return success or error

**Merge Settings:**

1. `setMergeSettings(settings: MergeSettings)`:
   - Call `gh api` to update repository settings
   - Configure allow-squash, allow-merge, allow-rebase options
   - Return success or error

### 9. Authentication and Setup

Implement authentication workflow:

**Check Authentication:**

1. `checkAuth(): Promise<Result<{ authenticated: boolean, username?: string }>>`:
   - Run `gh auth status` command
   - Parse output to determine if authenticated
   - Return username if authenticated, or false with error

**Authenticate:**

1. `authenticate(install: boolean, force: boolean): Promise<Result<void>>`:
   - If `install` flag: check if `gh` installed, run installation script if missing
   - If `force` flag or not authenticated: run `gh auth login`
   - Handle interactive authentication flow
   - Return success or error with remediation steps

**Installation:**

1. Detect OS (macOS, Linux, Windows)
2. Provide installation commands:
   - macOS: `brew install gh`
   - Linux: Package manager instructions
   - Windows: `winget install GitHub.cli`
3. Execute installation if `--install` flag provided
4. Follow with authentication

### 10. Error Handling and Retries

Implement robust error handling:

**Transient Error Detection:**

1. Network errors: Retry with exponential backoff (3 attempts, 1s, 2s, 4s delays)
2. Rate limit errors: Wait for retry-after period or calculated backoff
3. 5xx server errors: Retry with backoff

**Permanent Error Handling:**

1. Auth errors: Return immediately with remediation (run `gh auth login`)
2. Not found errors: Return immediately with clear message
3. Permission errors: Return with required scopes/permissions list
4. Invalid input: Return with validation error details

**Timeout Protection:**

1. Wrap all `execSync` calls with timeout (default 30s)
2. Long-running operations (large PR lists) get extended timeout (60s)
3. Timeout triggers `GitHubNetworkError` with remediation

### 11. Testing Strategy

Comprehensive test coverage:

**Unit Tests (90% target):**

1. **Type Tests**: Verify Result type guards work correctly
2. **Error Tests**: Test each error type construction and serialization
3. **Adapter Tests**: Mock `execSync`, test each GitHubAdapter method
   - Success cases with expected JSON output
   - Error cases with various CLI error patterns
   - Edge cases (empty results, malformed JSON, timeouts)
4. **CLI Parser Tests**: Test command routing and argument parsing
   - Valid commands route correctly
   - Invalid commands show help
   - Flags parse into correct types
5. **Template Tests**: Test frontmatter parsing and placeholder replacement
6. **Repository Detection Tests**: Test git remote parsing

**Integration Tests (optional, require `gh` CLI):**

1. **Issue Operations**: Create, get, update, comment, close issues
2. **PR Operations**: Find PRs, get metadata, comment, review
3. **Repository Operations**: Get info, manage labels
4. **Auth Operations**: Check status (without modifying auth)

**Mock Testing:**

1. All playbook tests use `MockGitHubClient`
2. Verify playbooks work without network access
3. Test error handling with mock errors

---

## Usage Examples

### Basic CLI Usage

```bash
# Find issues by pattern
catalyst-github issue find "bug in login"

# Get issue with all comments
catalyst-github issue get 123 --with-comments

# Create issue from playbook
catalyst-github issue create \
  --title "Add dark mode support" \
  --body "Users requested dark theme option" \
  --label "enhancement"

# Find unresolved PR threads
catalyst-github pr threads 45

# Reply to PR thread
catalyst-github pr reply 45 12345 "Fixed in latest commit"

# Get repository info
catalyst-github repo info --json
```

### Programmatic Usage in Playbooks

```typescript
import { GitHubAdapter, Result, Issue } from './src/playbooks/scripts/github';

// Initialize adapter
const github = new GitHubAdapter();

// Fetch issue with error handling
const result: Result<Issue> = await github.getIssue(123);
if (!result.success) {
  console.error(`Failed to get issue: ${result.error.message}`);
  console.error(`Remediation: ${result.error.remediation}`);
  return;
}

const issue = result.data;
console.log(`Issue #${issue.number}: ${issue.title}`);

// Find PR threads needing replies
const threadsResult = await github.findPRThreads(45);
if (threadsResult.success) {
  for (const thread of threadsResult.data) {
    // Reply to each unresolved thread
    await github.replyToThread(45, thread.threadId, "Addressed this feedback");
  }
}
```

### Testing with Mock Client

```typescript
import { MockGitHubClient, Issue } from './src/playbooks/scripts/github';

// Create mock with seed data
const mockGitHub = new MockGitHubClient({
  issues: [
    { number: 1, title: "Test issue", body: "Description", state: "open", labels: [] }
  ]
});

// Use in tests
const result = await mockGitHub.getIssue(1);
expect(result.success).toBe(true);
expect(result.data?.title).toBe("Test issue");
```
