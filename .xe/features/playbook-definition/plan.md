---
id: playbook-definition
title: Playbook Definition
author: "@flanakin"
description: "This document defines the implementation plan for the Playbook Definition feature for engineers. The document is generated by Catalyst AI and reviewed by the feature architect."
dependencies:
  - error-handling
---

<!-- markdownlint-disable single-title -->

# Implementation Plan: Playbook Definition

> [CRITICAL INSTRUCTION]
> This implementation plan describes the full implementation of the feature **from scratch**, as if no code exists. Do NOT write this as an enhancement or modification to existing code. Use language like "Create", "Implement", "Build" - NOT "Modify", "Add to", "Update".

**Spec**: [Feature spec](./spec.md)

---

## Summary

The Playbook Definition feature provides TypeScript interface contracts for the Catalyst workflow engine, including playbook structure (Playbook, PlaybookStep), action contracts (PlaybookAction, PlaybookActionResult), and execution state (PlaybookState, PlaybookContext). These format-agnostic interfaces enable playbooks to be constructed from any format (YAML, JSON, TypeScript) while engines and actions work exclusively with TypeScript types. The feature includes a StatePersistence class for saving and resuming execution using atomic file writes to prevent corruption.

**Design rationale**: See [research.md](./research.md) for analysis of interface design patterns, generic type approaches, and serialization strategies.

---

## Technical Context

This feature implementation plan extends the technical architecture defined in `.xe/architecture.md`.

**Feature-specific technical details:**

- **Primary Components**: TypeScript interface definitions, state persistence class with atomic writes
- **Data Structures**: `Playbook`, `PlaybookStep`, `PlaybookAction<TConfig>`, `PlaybookActionResult`, `PlaybookState`, `PlaybookContext`, `StatePersistence`, `ValidationRule` hierarchy
- **Dependencies**: `error-handling` (CatalystError and ErrorPolicy), Node.js >= 18 for file operations
- **Configuration**: State files in `.xe/runs/`, history in `.xe/runs/history/`, `.gitignore` in history directory only
- **Performance Goals**: State serialization <100ms for states <1MB, atomic write operations
- **Testing Framework**: Jest with 100% coverage for state persistence operations
- **Key Constraints**: State files must be JSON-serializable, file operations must be atomic, interfaces have zero runtime overhead

---

## Project Structure

```text
src/
  playbooks/
    scripts/
      playbooks/
        types/
          playbook.ts             # Playbook, PlaybookStep, InputParameter interfaces
          action.ts               # PlaybookAction, PlaybookActionResult interfaces
          action-metadata.ts      # ActionMetadata, JSONSchemaObject interfaces
          dependencies.ts         # PlaybookActionDependencies, CliDependency, EnvDependency
          state.ts                # PlaybookState, PlaybookContext interfaces
          validation.ts           # ValidationRule hierarchy
        persistence/
          state-persistence.ts    # StatePersistence class implementation
          atomic-write.ts         # Atomic file write utility
        registry/
          action-registry.ts      # AUTO-GENERATED: ACTION_REGISTRY export
        services/
          dependency-checker.ts   # DependencyChecker service
scripts/
  generate-action-registry.ts     # Build script: Generate ACTION_REGISTRY
tests/
  unit/
    playbooks/
      persistence/              # State persistence tests
      services/                 # DependencyChecker tests
  fixtures/
    playbooks/
      states/                   # Sample state files for testing
```

---

## Data Model

**Entities owned by this feature:**

- **Playbook**: TypeScript interface defining workflow structure
  - `name`: string (kebab-case, unique identifier)
  - `description`: string (human-readable purpose)
  - `owner`: string (responsible role)
  - `steps`: PlaybookStep[] (execution steps)
  - `reviewers`: { required: string[], optional: string[] } (optional)
  - `triggers`: Array<{ event: string, action: string, args?: Record<string, unknown> }> (optional)
  - `inputs`: InputParameter[] (optional)
  - `outputs`: Record<string, string> (optional, kebab-case keys)
  - `catch`: Array<{ code: string, steps: PlaybookStep[] }> (optional)
  - `finally`: PlaybookStep[] (optional)

- **PlaybookStep**: Step structure for execution engine
  - `action`: string (action type identifier in kebab-case)
  - `config`: unknown (action-specific configuration)
  - `name`: string (optional, step identifier)
  - `errorPolicy`: ErrorPolicy | ErrorAction (optional, from error-handling feature)

- **PlaybookAction<TConfig>**: Interface for action implementations
  - `execute(config: TConfig): Promise<PlaybookActionResult>` (execution method)

- **PlaybookActionResult**: Step execution outcome
  - `code`: string (optional, result/error code)
  - `message`: string (optional, human-readable message)
  - `value`: unknown (optional, action output)
  - `error`: CatalystError (optional, error details; null indicates success)

- **InputParameter**: Playbook input parameter definition
  - `name`: string (parameter name in kebab-case)
  - `type`: 'string' | 'number' | 'boolean'
  - `description`: string (optional)
  - `required`: boolean (optional, default: false)
  - `default`: unknown (optional)
  - `allowed`: unknown[] (optional, enum values)
  - `validation`: InputValidationRule[] (optional)

- **ValidationRule**: Base interface for validation rules
  - `type`: string (discriminator, PascalCased)
  - `code`: string (optional, error code)
  - `message`: string (optional, custom error message)

- **RegexValidationRule**, **StringLengthValidationRule**, **NumberRangeValidationRule**, **CustomValidationRule**: Specific validation rule types extending ValidationRule

- **ValidationExecutor**: Class that executes validation rules against values
  - `validate(value: unknown, rules: InputValidationRule[]): ValidationResult` (main execution method)
  - Uses discriminated union pattern for type-based dispatch
  - Returns ValidationResult with success status and optional error

- **ValidationResult**: Outcome of validation execution
  - `valid`: boolean (validation passed)
  - `error`: ValidationError (optional, present when validation fails)

- **ValidationError**: Details about validation failure
  - `code`: string (error code from rule or default)
  - `message`: string (error message from rule or generated)
  - `rule`: InputValidationRule (the rule that failed)
  - `value`: unknown (the value that failed validation)

- **PlaybookState**: Serializable execution state
  - `playbookName`: string (playbook identifier)
  - `runId`: string (format: YYYYMMDD-HHMMSS-nnn)
  - `startTime`: string (ISO 8601 timestamp)
  - `inputs`: Record<string, unknown> (validated input parameters)
  - `variables`: Record<string, unknown> (inputs + var assignments + step outputs)
  - `completedSteps`: string[] (step names for resume)
  - `currentStepName`: string (current step being executed)
  - `status`: 'running' | 'paused' | 'completed' | 'failed'

- **PlaybookContext**: Runtime execution context (extends PlaybookState)
  - `playbook`: Playbook (playbook being executed, not serialized)

- **StatePersistence**: State persistence class
  - `save(state: PlaybookState): Promise<void>` (persist to disk)
  - `load(runId: string): Promise<PlaybookState>` (load from disk)
  - `archive(runId: string): Promise<void>` (move to history)
  - `listActiveRuns(): Promise<string[]>` (list active run IDs)
  - `pruneArchive(retentionDays: number): Promise<number>` (cleanup old runs)

**Entities from other features:**

- **CatalystError** (error-handling): Base error class with code and guidance
- **ErrorPolicy** (error-handling): Error handling configuration
- **ErrorAction** (error-handling): Shortcut string for error policies

---

## Contracts

### PlaybookAction Interface

**Signature:**

```typescript
interface PlaybookAction<TConfig = unknown> {
  execute(config: TConfig): Promise<PlaybookActionResult>;
  dependencies?: PlaybookActionDependencies;  // Optional dependency metadata
}
```

**Purpose:** Base interface all playbook actions must implement for execution. Optional dependencies property enables declarative documentation of external requirements.

**Parameters:**

- `config` (TConfig): Action-specific configuration extracted from PlaybookStep

**Returns:** `Promise<PlaybookActionResult>` with execution outcome (code, message, value, error; null error indicates success)

**Dependency Metadata:**

Actions can optionally declare external dependencies via static `dependencies` property:

```typescript
class BashAction implements PlaybookAction<string> {
  static readonly dependencies: PlaybookActionDependencies = {
    cli: [{
      name: 'bash',
      versionCommand: 'bash --version',
      platforms: ['linux', 'darwin'],
      installDocs: 'https://www.gnu.org/software/bash/'
    }]
  };

  async execute(script: string): Promise<PlaybookActionResult> {
    // Execute bash script
  }
}
```

**Examples:**

```typescript
// Basic action implementation
class GitHubIssueCreateAction implements PlaybookAction<string> {
  async execute(title: string): Promise<PlaybookActionResult> {
    const issue = await createIssue(title);
    return {
      code: 'IssueCreated',
      value: { number: issue.number, url: issue.html_url },
      error: null  // Success indicated by null error
    };
  }
}
```

```typescript
// Action with complex config
interface FileWriteConfig {
  path: string;
  content: string;
}

class FileWriteAction implements PlaybookAction<FileWriteConfig> {
  async execute(config: FileWriteConfig): Promise<PlaybookActionResult> {
    try {
      await writeFile(config.path, config.content);
      return {
        code: 'FileWritten',
        value: { path: config.path },
        error: null  // Success
      };
    } catch (err) {
      return {
        code: 'FileWriteFailed',
        message: `Failed to write ${config.path}`,
        error: new CatalystError('File write failed', 'FileWriteFailed', err)
      };
    }
  }
}
```

### StatePersistence Class

**Signature:**

```typescript
class StatePersistence {
  save(state: PlaybookState): Promise<void>;
  load(runId: string): Promise<PlaybookState>;
  archive(runId: string): Promise<void>;
  listActiveRuns(): Promise<string[]>;
  pruneArchive(retentionDays: number): Promise<number>;
}
```

**Purpose:** Provides state persistence operations for playbook execution resume capability

**Methods:**

- `save`: Persist playbook state to `.xe/runs/run-{runId}.json`
- `load`: Load playbook state from disk by run ID
- `archive`: Move completed run to `.xe/runs/history/{YYYY}/{MM}/{DD}/`
- `listActiveRuns`: Return array of active run IDs
- `pruneArchive`: Delete archived runs older than retention days

**Errors/Exceptions:**

- `StateError`: Thrown when save/load/archive fails or state is corrupted
- Includes recovery instructions in error message

**Examples:**

```typescript
// Save execution state
const persistence = new FileSystemStatePersistence();
await persistence.save({
  playbookName: 'my-playbook',
  runId: '20251128-143022-001',
  startTime: '2025-11-28T14:30:22Z',
  inputs: { 'issue-number': 123 },
  variables: { 'issue-number': 123, 'pr-number': 456 },
  completedSteps: ['step-1', 'step-2'],
  currentStepName: 'step-3',
  status: 'running'
});
```

```typescript
// Load and resume
const state = await persistence.load('20251128-143022-001');
console.log(`Resuming from step: ${state.currentStepName}`);
```

### DependencyChecker Service

**Signature:**

```typescript
class DependencyChecker {
  checkCli(dep: CliDependency): Promise<CheckResult>;
  checkEnv(dep: EnvDependency): Promise<CheckResult>;
}
```

**Purpose:** Platform-agnostic validation of external dependencies (CLI tools, environment variables)

**Methods:**

- `checkCli`: Validate CLI tool availability using two-tier strategy (version command → which/where)
- `checkEnv`: Validate environment variable presence

**Returns:** `CheckResult` with availability status, version info, and error guidance

**Examples:**

```typescript
const checker = new DependencyChecker();

// Check CLI tool
const bashResult = await checker.checkCli({
  name: 'bash',
  versionCommand: 'bash --version',
  minVersion: '5.0.0',
  platforms: ['linux', 'darwin']
});

if (!bashResult.available) {
  console.error(bashResult.error);  // "bash not found - install from..."
}

// Check environment variable
const tokenResult = await checker.checkEnv({
  name: 'GITHUB_TOKEN',
  required: true,
  description: 'GitHub API authentication'
});
```

---

## Implementation Approach

### 1. TypeScript Interface Definitions

Create playbook structure interfaces in `src/playbooks/scripts/playbooks/types/playbook.ts`:

```typescript
export interface Playbook {
  name: string;
  description: string;
  owner: string;
  steps: PlaybookStep[];
  reviewers?: {
    required: string[];
    optional: string[];
  };
  triggers?: Array<{
    event: string;
    action: string;
    args?: Record<string, unknown>;
  }>;
  inputs?: InputParameter[];
  outputs?: Record<string, string>;
  catch?: Array<{
    code: string;
    steps: PlaybookStep[];
  }>;
  finally?: PlaybookStep[];
}

export interface PlaybookStep {
  action: string;    // Action type identifier (e.g., 'github-issue-create')
  config: unknown;   // Action-specific configuration object
  name?: string;     // Step identifier for referencing results
  errorPolicy?: ErrorPolicy | ErrorAction;
}

export interface InputParameter {
  name: string;
  type: 'string' | 'number' | 'boolean';
  description?: string;
  required?: boolean;
  default?: unknown;
  allowed?: unknown[];
  validation?: InputValidationRule[];
}
```

Create validation rule interfaces in `src/playbooks/scripts/playbooks/types/validation.ts`:

```typescript
// Base interface all validation rules extend
export interface ValidationRule {
  type: string;      // Discriminator (PascalCased)
  code?: string;
  message?: string;
}

export interface RegexValidationRule extends ValidationRule {
  type: 'Regex';
  pattern: string;
}

export interface StringLengthValidationRule extends ValidationRule {
  type: 'StringLength';
  minLength?: number;
  maxLength?: number;
}

export interface NumberRangeValidationRule extends ValidationRule {
  type: 'NumberRange';
  min?: number;
  max?: number;
}

export interface CustomValidationRule extends ValidationRule {
  type: 'Custom';
  script: string;
}

// Union type for extensibility
export type InputValidationRule =
  | RegexValidationRule
  | StringLengthValidationRule
  | NumberRangeValidationRule
  | CustomValidationRule;

// Validation execution result
export interface ValidationResult {
  valid: boolean;
  error?: ValidationError;
}

// Validation error details
export interface ValidationError {
  code: string;
  message: string;
  rule: InputValidationRule;
  value: unknown;
}

// Validation executor class
export class ValidationExecutor {
  validate(value: unknown, rules: InputValidationRule[]): ValidationResult {
    for (const rule of rules) {
      const result = this.validateSingleRule(value, rule);
      if (!result.valid) {
        return result;
      }
    }
    return { valid: true };
  }

  private validateSingleRule(value: unknown, rule: InputValidationRule): ValidationResult {
    switch (rule.type) {
      case 'Regex':
        return this.validateRegex(value, rule);
      case 'StringLength':
        return this.validateStringLength(value, rule);
      case 'NumberRange':
        return this.validateNumberRange(value, rule);
      case 'Custom':
        return this.validateCustom(value, rule);
      default:
        throw new Error(`Unknown validation rule type: ${(rule as any).type}`);
    }
  }

  private validateRegex(value: unknown, rule: RegexValidationRule): ValidationResult {
    if (typeof value !== 'string') {
      return {
        valid: false,
        error: {
          code: rule.code || 'InvalidType',
          message: rule.message || 'Value must be a string',
          rule,
          value
        }
      };
    }

    const regex = new RegExp(rule.pattern);
    if (!regex.test(value)) {
      return {
        valid: false,
        error: {
          code: rule.code || 'RegexMismatch',
          message: rule.message || `Value does not match pattern: ${rule.pattern}`,
          rule,
          value
        }
      };
    }

    return { valid: true };
  }

  private validateStringLength(value: unknown, rule: StringLengthValidationRule): ValidationResult {
    if (typeof value !== 'string') {
      return {
        valid: false,
        error: {
          code: rule.code || 'InvalidType',
          message: rule.message || 'Value must be a string',
          rule,
          value
        }
      };
    }

    if (rule.minLength !== undefined && value.length < rule.minLength) {
      return {
        valid: false,
        error: {
          code: rule.code || 'TooShort',
          message: rule.message || `Value must be at least ${rule.minLength} characters`,
          rule,
          value
        }
      };
    }

    if (rule.maxLength !== undefined && value.length > rule.maxLength) {
      return {
        valid: false,
        error: {
          code: rule.code || 'TooLong',
          message: rule.message || `Value must be at most ${rule.maxLength} characters`,
          rule,
          value
        }
      };
    }

    return { valid: true };
  }

  private validateNumberRange(value: unknown, rule: NumberRangeValidationRule): ValidationResult {
    if (typeof value !== 'number') {
      return {
        valid: false,
        error: {
          code: rule.code || 'InvalidType',
          message: rule.message || 'Value must be a number',
          rule,
          value
        }
      };
    }

    if (rule.min !== undefined && value < rule.min) {
      return {
        valid: false,
        error: {
          code: rule.code || 'TooSmall',
          message: rule.message || `Value must be at least ${rule.min}`,
          rule,
          value
        }
      };
    }

    if (rule.max !== undefined && value > rule.max) {
      return {
        valid: false,
        error: {
          code: rule.code || 'TooLarge',
          message: rule.message || `Value must be at most ${rule.max}`,
          rule,
          value
        }
      };
    }

    return { valid: true };
  }

  private validateCustom(value: unknown, rule: CustomValidationRule): ValidationResult {
    try {
      // Create a function from the script that has access to 'value'
      const fn = new Function('value', `return (${rule.script});`);
      const result = fn(value);

      if (typeof result !== 'boolean') {
        throw new Error('Custom validation script must return a boolean');
      }

      if (!result) {
        return {
          valid: false,
          error: {
            code: rule.code || 'CustomValidationFailed',
            message: rule.message || 'Custom validation failed',
            rule,
            value
          }
        };
      }

      return { valid: true };
    } catch (err) {
      return {
        valid: false,
        error: {
          code: rule.code || 'CustomValidationError',
          message: rule.message || `Custom validation script error: ${(err as Error).message}`,
          rule,
          value
        }
      };
    }
  }
}
```

Create action interfaces in `src/playbooks/scripts/playbooks/types/action.ts`:

```typescript
export interface PlaybookAction<TConfig = unknown> {
  execute(config: TConfig): Promise<PlaybookActionResult>;
}

export interface PlaybookActionResult {
  code?: string;
  message?: string;
  value?: unknown;
  error?: CatalystError;  // null indicates success
}
```

Create state interfaces in `src/playbooks/scripts/playbooks/types/state.ts`:

```typescript
export interface PlaybookState {
  playbookName: string;
  runId: string;
  startTime: string;
  status: 'running' | 'paused' | 'completed' | 'failed';
  inputs: Record<string, unknown>;
  variables: Record<string, unknown>;
  completedSteps: string[];
  currentStepName: string;
}

export interface PlaybookContext extends PlaybookState {
  playbook: Playbook;
}

export class StateError extends CatalystError {
  constructor(message: string, code: string, cause?: Error) {
    super(message, code, cause);
  }
}
```

### 2. State Persistence Implementation

Implement `StatePersistence` class in `src/playbooks/scripts/playbooks/persistence/state-persistence.ts`:

**save(state: PlaybookState) implementation approach:**

1. Build file path as `.xe/runs/run-{runId}.json`
2. Serialize state to pretty-printed JSON (`JSON.stringify(state, null, 2)`)
3. Create `.xe/runs/` directory if it doesn't exist (recursive: true)
4. Write using atomic write utility (see below)
5. On error, throw `StateError` with recovery instructions

**load(runId: string) implementation approach:**

1. Build file path as `.xe/runs/run-{runId}.json`
2. Read file content as UTF-8
3. Parse JSON to PlaybookState object
4. Validate required fields exist (runId, playbookName)
5. On missing file or corrupted JSON, throw `StateError` with actionable message
6. Return deserialized state

**archive(runId: string) implementation approach:**

1. Parse date from runId format (YYYYMMDD-HHMMSS-nnn)
2. Extract year, month, day components
3. Build history path as `.xe/runs/history/{YYYY}/{MM}/{DD}/`
4. Create nested directory structure (recursive: true)
5. Check if `.xe/runs/history/.gitignore` exists, create if missing (content: `*\n`)
6. Read source state file from `.xe/runs/`
7. Write to history path using atomic write
8. Delete source file from `.xe/runs/`
9. On error, throw `StateError` preserving original file

**listActiveRuns() implementation approach:**

1. Read directory `.xe/runs/`
2. Filter for files matching `run-*.json` pattern
3. Extract runId from filename (strip `run-` prefix and `.json` suffix)
4. Sort alphabetically and return array

**pruneArchive(retentionDays: number) implementation approach:**

1. Calculate cutoff date (current date - retentionDays)
2. Recursively scan `.xe/runs/history/` directory tree
3. For each JSON file, check modification time (stat.mtime)
4. Delete files older than cutoff date
5. Count deletions and return total
6. Continue on errors (directory might not exist yet)

### 3. Atomic Write Utility

Implement `atomicWrite(path: string, content: string)` function in `src/playbooks/scripts/playbooks/persistence/atomic-write.ts`:

**Implementation approach:**

1. Generate unique temp file path: `{path}.tmp-{randomHex}`
2. Ensure parent directory exists (mkdir with recursive: true)
3. Write content to temp file
4. Atomically rename temp file to target path (rename is atomic on POSIX filesystems)
5. On error, attempt to clean up temp file (ignore cleanup errors)
6. Propagate original error

This pattern prevents corruption if process crashes during write, as the original file remains intact until the atomic rename operation.

### 4. Action Metadata Registry Generation

Implement ACTION_REGISTRY generation in `scripts/generate-action-registry.ts`:

**Purpose**: Generate `ACTION_REGISTRY` at build time by scanning action files and extracting metadata (dependencies, primaryProperty, configSchema).

**Implementation approach:**

1. **Scan for action files**:
   - Use glob to find all `*-action.ts` files in `src/playbooks/scripts/playbooks/actions/`
   - Extract action type from filename (remove `-action.ts` suffix)

2. **Extract static properties**:
   - Dynamically import each action module
   - Extract `static readonly dependencies: PlaybookActionDependencies` (if present)
   - Extract `static readonly primaryProperty: string` (if present)
   - Skip `configSchema` extraction (generated separately, see below)

3. **Generate config schemas from TypeScript interfaces**:
   - Use `typescript-json-schema` library to generate JSON schemas
   - Target: All interfaces ending with `Config` suffix (e.g., `BashConfig`, `PowerShellConfig`)
   - Options:
     - `required: true` - Mark non-optional properties as required
     - `noExtraProps: true` - Disallow additional properties unless explicitly allowed
     - `include: ['src/playbooks/scripts/playbooks/actions/**/*.ts']` - Scan action directories
   - For each action, match config interface name: `{ActionClass}Config` → action type
   - Example: `BashAction` uses `BashConfig` → generate schema for `BashConfig` → assign to `bash` in registry

4. **Build ActionMetadata objects**:
   - For each action, create `ActionMetadata` object with:
     - `dependencies` (from static property, optional)
     - `primaryProperty` (from static property, optional)
     - `configSchema` (from generated schemas, optional)
   - Only include actions with at least one metadata property

5. **Generate TypeScript registry file**:
   - Output to: `src/playbooks/scripts/playbooks/registry/action-registry.ts`
   - Export: `export const ACTION_REGISTRY: Record<string, ActionMetadata>`
   - Include JSDoc with usage examples
   - Add header comment: `// AUTO-GENERATED - DO NOT EDIT MANUALLY`

6. **Integrate with build process**:
   - Add to build script: `generate-action-registry` → `tsc`
   - Ensure registry generation runs before TypeScript compilation
   - Fail build if registry generation fails

**typescript-json-schema configuration:**

```typescript
const settings: Settings = {
  required: true,           // Mark non-optional properties as required
  noExtraProps: true,       // Disallow additional properties
  include: ['src/playbooks/scripts/playbooks/actions/**/*.ts'],
  ref: false,               // Inline references instead of using $ref
  titles: true,             // Include title from interface name
  defaultProps: false       // Don't add default properties
};

const program = TJS.getProgramFromFiles([configFile], compilerOptions);
const schema = TJS.generateSchema(program, configInterfaceName, settings);
```

**Example generated registry entry:**

```typescript
{
  "bash": {
    "dependencies": {
      "cli": [{
        "name": "bash",
        "versionCommand": "bash --version",
        "platforms": ["linux", "darwin"],
        "installDocs": "https://www.gnu.org/software/bash/"
      }]
    },
    "primaryProperty": "code",
    "configSchema": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "Bash script to execute"
        },
        "cwd": {
          "type": "string",
          "description": "Working directory for script execution"
        },
        "env": {
          "type": "object",
          "additionalProperties": { "type": "string" },
          "description": "Environment variables for script execution"
        },
        "timeout": {
          "type": "number",
          "description": "Maximum execution time in milliseconds"
        }
      },
      "required": ["code"]
    }
  }
}
```

### 5. Error Handling

Define error scenarios and handling:

1. **State persistence failures**:
   - File system errors → Throw `StateError` with recovery instructions
   - Permission errors → Throw `StateError` with directory path
   - Disk full → Throw `StateError` with space requirement

2. **State loading failures**:
   - Missing state file → Throw `StateError` indicating runId not found
   - Invalid JSON → Throw `StateError` with corruption details and suggestion to restore from backup
   - Invalid state structure → Throw `StateError` with migration guidance

3. **Archive failures**:
   - Date parsing errors → Throw `StateError` with runId format requirement
   - Directory creation failure → Throw `StateError` with permission issue
   - Move operation failure → Throw `StateError` preserving original file

### 5. Performance Considerations

Optimization strategies:

1. **State serialization**:
   - Use `JSON.stringify()` with pretty-printing (readable)
   - Implement size warnings at 500KB, errors at 5MB
   - Target: <100ms for states <1MB

2. **File operations**:
   - Use atomic writes to prevent corruption
   - Use async I/O for all file operations (Node.js fs/promises)
   - Buffer writes for better performance

3. **Archive pruning**:
   - Scan directories recursively only when needed
   - Use file system timestamps for efficient filtering
   - Process deletes in batches for large archives

### 6. Testing Strategy

**Unit Tests:**

1. **State persistence tests** (`tests/unit/playbooks/persistence/state-persistence.test.ts`):
   - Save creates file at correct path with pretty-printed JSON
   - Save creates parent directory if missing
   - Save uses atomic write (temp file + rename)
   - Load returns correct deserialized state
   - Load throws StateError for missing file
   - Load throws StateError for corrupted JSON
   - Load throws StateError for invalid state structure
   - Archive moves file to correct history directory (`.xe/runs/history/{YYYY}/{MM}/{DD}/`)
   - Archive creates nested date directories
   - Archive creates `.gitignore` in history root on first archive
   - ListActiveRuns returns correct run IDs sorted
   - PruneArchive deletes files older than retention days
   - PruneArchive preserves recent files
   - PruneArchive returns correct deletion count

2. **Atomic write tests** (`tests/unit/playbooks/persistence/atomic-write.test.ts`):
   - Creates parent directories if missing
   - Writes to temp file with random suffix
   - Renames temp to target atomically
   - Cleans up temp file on error
   - Handles permission errors gracefully
   - Handles disk full errors

**Integration Tests:**

1. **End-to-end state lifecycle** (`tests/integration/playbooks/state-lifecycle.test.ts`):
   - Create state → Save → Load → Verify equality
   - Create state → Save → Archive → Verify file in history
   - Multiple saves update same file without corruption
   - Concurrent saves don't corrupt state (atomic writes)
   - Prune archive with mixed old/new files

**Performance Tests:**

1. State serialization completes in <100ms for 1MB state
2. Atomic write completes in <50ms for typical state size
3. Archive operation completes in <100ms
4. List active runs completes in <50ms for 100 runs

**Coverage Targets:**

- 100% coverage for state persistence error handling
- 100% coverage for atomic write edge cases
- 95% overall coverage for the feature

---

## Usage Examples

### Basic Usage: Defining an Action

```typescript
import { PlaybookAction, PlaybookActionResult } from '@catalyst/playbooks/types';

// Define action configuration type
interface MyActionConfig {
  inputValue: string;
  options?: {
    flag: boolean;
  };
}

// Implement PlaybookAction interface
class MyAction implements PlaybookAction<MyActionConfig> {
  async execute(config: MyActionConfig): Promise<PlaybookActionResult> {
    try {
      // Perform action logic
      const result = await doSomething(config.inputValue);

      // Return structured result (error null indicates success)
      return {
        code: 'MyActionCompleted',
        message: `Processed ${config.inputValue}`,
        value: result,
        error: null
      };
    } catch (err) {
      return {
        code: 'MyActionFailed',
        message: `Failed to process ${config.inputValue}`,
        error: new CatalystError('Action failed', 'MyActionFailed', err)
      };
    }
  }
}
```

### Integration Pattern: State Persistence

```typescript
import { StatePersistence, PlaybookState } from '@catalyst/playbooks/types';

// Initialize persistence service
const persistence = new StatePersistence();

// Save execution state
const state: PlaybookState = {
  playbookName: 'my-workflow',
  runId: '20251128-143022-001',
  startTime: new Date().toISOString(),
  inputs: { 'user-id': 123 },
  variables: { 'user-id': 123, 'user-name': 'Alice' },
  completedSteps: ['validate-input', 'fetch-user'],
  currentStepName: 'process-data',
  status: 'running'
};

await persistence.save(state);

// Later: Resume execution
const loadedState = await persistence.load('20251128-143022-001');
console.log(`Resuming from: ${loadedState.currentStepName}`);

// After completion: Archive
state.status = 'completed';
await persistence.save(state);
await persistence.archive(state.runId);

// Cleanup old runs
const deleted = await persistence.pruneArchive(30); // Keep 30 days
console.log(`Pruned ${deleted} old runs`);
```
