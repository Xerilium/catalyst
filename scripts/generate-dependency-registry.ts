#!/usr/bin/env tsx

/**
 * Build script: Generate dependency registry from action implementations
 *
 * Scans all action files in src/playbooks/scripts/playbooks/actions/
 * and extracts dependency metadata to generate registry TypeScript file.
 *
 * Usage: tsx scripts/generate-dependency-registry.ts [--test]
 *   --test: Generate registry from test fixtures instead
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';
import type { PlaybookActionDependencies } from '../src/playbooks/scripts/playbooks/types';

interface RegistryEntry {
  [actionType: string]: PlaybookActionDependencies;
}

async function generateRegistry(testMode = false): Promise<void> {
  console.log(`[Registry] ${testMode ? 'Test mode' : 'Production mode'}`);

  // Determine scan path
  const baseDir = testMode
    ? 'tests/fixtures/actions'
    : 'src/playbooks/scripts/playbooks/actions';

  // Find all *-action.ts files
  const pattern = path.join(baseDir, '**/*-action.ts');
  console.log(`[Registry] Scanning: ${pattern}`);

  const actionFiles = await glob(pattern, {
    absolute: true,
    nodir: true
  });

  console.log(`[Registry] Found ${actionFiles.length} action files`);

  const registry: RegistryEntry = {};

  // Process each action file
  for (const filePath of actionFiles) {
    try {
      // Dynamically import the module
      const module = await import(filePath);

      // Find exported classes with dependencies
      for (const exportName of Object.keys(module)) {
        const exported = module[exportName];

        // Check if it's a class constructor with dependencies
        if (
          typeof exported === 'function' &&
          exported.prototype &&
          'execute' in exported.prototype &&
          'dependencies' in exported
        ) {
          // Extract action type from filename (remove -action.ts suffix)
          const filename = path.basename(filePath, '.ts');
          const actionType = filename.replace(/-action$/, '');

          // Add to registry
          registry[actionType] = exported.dependencies as PlaybookActionDependencies;

          console.log(`[Registry] ✓ ${actionType}: ${JSON.stringify(exported.dependencies).substring(0, 50)}...`);
        }
      }
    } catch (err) {
      console.error(`[Registry] ✗ Failed to process ${filePath}:`, (err as Error).message);
      throw err; // Fail build on errors
    }
  }

  // Generate TypeScript file
  const output = testMode
    ? path.join('tests/fixtures', 'dependency-registry.ts')
    : path.join('src/playbooks/scripts/playbooks/registry', 'dependency-registry.ts');

  // Ensure output directory exists
  await fs.mkdir(path.dirname(output), { recursive: true });

  const content = `// AUTO-GENERATED - DO NOT EDIT MANUALLY
// Generated by scripts/generate-dependency-registry.ts
//
// This file is automatically generated at build time from action implementations.
// To update dependencies, modify the action class's static dependencies property.

import type { PlaybookActionDependencies } from '../types/dependencies';

/**
 * Auto-generated registry of action dependencies
 *
 * Maps action types (kebab-case) to their declared dependencies.
 * Generated at build time by scanning action implementations.
 */
export const DEPENDENCY_REGISTRY: Record<string, PlaybookActionDependencies> = ${JSON.stringify(registry, null, 2)};
`;

  await fs.writeFile(output, content, 'utf-8');
  console.log(`[Registry] Generated: ${output}`);
  console.log(`[Registry] Total entries: ${Object.keys(registry).length}`);
}

// Parse CLI arguments
const testMode = process.argv.includes('--test');

// Run generation
generateRegistry(testMode)
  .then(() => {
    console.log('[Registry] Success!');
    process.exit(0);
  })
  .catch((err) => {
    console.error('[Registry] Failed:', err);
    process.exit(1);
  });
