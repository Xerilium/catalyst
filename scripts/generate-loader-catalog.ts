#!/usr/bin/env tsx

/**
 * Build script: Generate loader catalog from loader implementations
 *
 * Scans all loader files in src/playbooks/ directories
 * to find PlaybookLoader implementations and generates a catalog TypeScript file.
 *
 * The catalog includes:
 * - LOADER_CATALOG: Metadata for each loader (name, supportedExtensions)
 * - LOADER_CLASSES: Map of loaderName to actual class constructor
 * - Import statements for all loader classes
 *
 * Usage: tsx scripts/generate-loader-catalog.ts
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';

interface LoaderInfo {
  name: string;
  className: string;
  importPath: string;  // Relative path for import statement
}

async function generateLoaderCatalog(): Promise<void> {
  console.log(`[LoaderCatalog] Scanning for PlaybookLoader implementations...`);

  // Find all loader.ts files (convention: loaders are in **/loader.ts)
  // Also support *-loader.ts pattern
  const loaderFiles = await glob([
    'src/playbooks/**/loader.ts',
    'src/playbooks/**/*-loader.ts'
  ], {
    absolute: true,
    nodir: true,
    // Exclude the types folder and index files
    ignore: ['**/types/**', '**/index.ts']
  });

  console.log(`[LoaderCatalog] Found ${loaderFiles.length} potential loader files`);

  const loaders: LoaderInfo[] = [];

  // Process each loader file
  for (const filePath of loaderFiles) {
    try {
      // Dynamically import the module
      const module = await import(filePath);

      // Find exported classes that implement PlaybookLoader interface
      for (const exportName of Object.keys(module)) {
        const exported = module[exportName];

        // Check if it's a class constructor with load and supports methods
        if (
          typeof exported === 'function' &&
          exported.prototype &&
          'load' in exported.prototype &&
          'supports' in exported.prototype &&
          'name' in new exported()
        ) {
          // Create instance to get the name property
          const instance = new exported();
          const loaderName = instance.name;

          if (typeof loaderName !== 'string') {
            console.warn(`[LoaderCatalog] ⚠ ${exportName}: name property is not a string, skipping`);
            continue;
          }

          // Calculate relative import path from the generated file location
          // Generated file: src/playbooks/registry/loader-catalog.ts
          const relativeFromRegistry = path.relative(
            path.resolve('src/playbooks/registry'),
            filePath.replace('.ts', '')
          );

          loaders.push({
            name: loaderName,
            className: exportName,
            importPath: relativeFromRegistry
          });

          console.log(`[LoaderCatalog] ✓ ${loaderName}: Found ${exportName} in ${path.basename(filePath)}`);
        }
      }
    } catch (err) {
      console.warn(`[LoaderCatalog] ⚠ Could not process ${filePath}: ${(err as Error).message}`);
    }
  }

  if (loaders.length === 0) {
    console.log(`[LoaderCatalog] No loaders found, skipping generation`);
    return;
  }

  // Generate TypeScript file
  const output = path.join('src/playbooks/registry', 'loader-catalog.ts');

  // Ensure output directory exists
  await fs.mkdir(path.dirname(output), { recursive: true });

  // Generate import statements for all loader classes
  const imports = loaders.map(
    ({ className, importPath }) => `import { ${className} } from '${importPath}';`
  ).join('\n');

  // Generate LOADER_CLASSES mapping
  const classMapEntries = loaders.map(
    ({ className }) => `  '${className}': ${className}`
  ).join(',\n');

  // Generate loader order (alphabetical by name)
  const loaderOrder = loaders.map(l => `'${l.name}'`).join(', ');

  const content = `// AUTO-GENERATED - DO NOT EDIT MANUALLY
// Generated by scripts/generate-loader-catalog.ts
//
// This file is automatically generated at build time from loader implementations.
// To add a new loader, create a class that implements PlaybookLoader interface.

import type { PlaybookLoader } from '../types/playbook-loader';

// Loader class imports (auto-generated)
${imports}

/**
 * Loader constructor type
 */
export type LoaderConstructor = new () => PlaybookLoader;

/**
 * Auto-generated map of className to loader constructor
 *
 * Enables dynamic loader instantiation for registration.
 *
 * Generated at build time by scanning loader implementations.
 */
export const LOADER_CLASSES: Record<string, LoaderConstructor> = {
${classMapEntries}
};

/**
 * Default loader registration order
 *
 * Loaders are tried in this order during playbook loading.
 * First loader that returns a playbook wins.
 */
export const DEFAULT_LOADER_ORDER: string[] = [${loaderOrder}];

/**
 * Initialize all loaders by registering them with PlaybookProvider
 *
 * Called during application startup. Creates instances of all discovered
 * loaders and registers them with the provider.
 */
export function initializeLoaders(): void {
  // Import here to avoid circular dependency
  const { PlaybookProvider } = require('./playbook-provider');
  const provider = PlaybookProvider.getInstance();

  for (const [className, LoaderClass] of Object.entries(LOADER_CLASSES)) {
    const loader = new LoaderClass();
    provider.register(loader);
  }
}
`;

  await fs.writeFile(output, content, 'utf-8');
  console.log(`[LoaderCatalog] Generated: ${output}`);
  console.log(`[LoaderCatalog] Total loaders: ${loaders.length}`);
}

// Run generation
generateLoaderCatalog()
  .then(() => {
    console.log('[LoaderCatalog] Success!');
    process.exit(0);
  })
  .catch((err) => {
    console.error('[LoaderCatalog] Failed:', err);
    process.exit(1);
  });
