#!/usr/bin/env tsx

/**
 * Build script: Generate AI provider catalog from provider implementations
 *
 * Scans all provider files in src/playbooks/scripts/playbooks/actions/ai/providers/
 * and extracts metadata to generate a unified provider catalog TypeScript file.
 *
 * The catalog includes:
 * - PROVIDER_CATALOG: Map of provider names to their class constructors
 * - Import statements for all provider classes
 *
 * Providers must:
 * - Export a class implementing AIProvider interface
 * - Have a `name` instance property matching the provider identifier
 * - Be in a file matching *-provider.ts pattern
 *
 * Usage: tsx scripts/generate-provider-registry.ts
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';

interface ProviderInfo {
  name: string;        // Provider identifier (e.g., 'claude', 'mock')
  className: string;   // Class name (e.g., 'ClaudeProvider', 'MockAIProvider')
  importPath: string;  // Relative path for import statement
}

async function generateCatalog(): Promise<void> {
  console.log('[Provider Catalog] Starting generation...');

  // Find all *-provider.ts files
  const baseDir = 'src/playbooks/scripts/playbooks/actions/ai/providers';
  const pattern = path.join(baseDir, '*-provider.ts');
  console.log(`[Provider Catalog] Scanning: ${pattern}`);

  const providerFiles = await glob(pattern, {
    absolute: true,
    nodir: true
  });

  console.log(`[Provider Catalog] Found ${providerFiles.length} provider files`);

  const providers: ProviderInfo[] = [];

  // Process each provider file
  for (const filePath of providerFiles) {
    try {
      // Dynamically import the module
      const module = await import(filePath);

      // Find exported classes with execute method (AIProvider interface)
      for (const exportName of Object.keys(module)) {
        const exported = module[exportName];

        // Check if it's a class constructor implementing AIProvider
        if (
          typeof exported === 'function' &&
          exported.prototype &&
          'execute' in exported.prototype &&
          'isAvailable' in exported.prototype &&
          'signIn' in exported.prototype
        ) {
          // Create instance to get name property
          let providerName: string;
          try {
            const instance = new exported();
            if (!('name' in instance) || typeof instance.name !== 'string') {
              console.error(`[Provider Catalog] ✗ ${exportName}: Missing 'name' property`);
              continue;
            }
            providerName = instance.name;
          } catch (err) {
            console.error(`[Provider Catalog] ✗ ${exportName}: Could not instantiate: ${(err as Error).message}`);
            continue;
          }

          // Validate provider name format (lowercase, alphanumeric, hyphens)
          if (!/^[a-z][a-z0-9-]*$/.test(providerName)) {
            console.error(`[Provider Catalog] ✗ ${exportName}: name '${providerName}' must be lowercase alphanumeric with hyphens`);
            continue;
          }

          // Check for duplicate provider names
          const existing = providers.find(p => p.name === providerName);
          if (existing) {
            console.error(`[Provider Catalog] ✗ Duplicate provider name '${providerName}' in ${exportName}`);
            console.error(`[Provider Catalog]   Already defined by ${existing.className}`);
            throw new Error(`Duplicate provider name '${providerName}'`);
          }

          // Calculate relative import path
          // Generated file: src/playbooks/scripts/playbooks/actions/ai/providers/provider-catalog.ts
          // Provider files: src/playbooks/scripts/playbooks/actions/ai/providers/*-provider.ts
          const relativePath = './' + path.basename(filePath, '.ts');

          providers.push({
            name: providerName,
            className: exportName,
            importPath: relativePath
          });

          console.log(`[Provider Catalog] ✓ ${providerName}: ${exportName}`);
        }
      }
    } catch (err) {
      console.error(`[Provider Catalog] ✗ Failed to process ${filePath}:`, (err as Error).message);
      throw err;
    }
  }

  // Generate TypeScript file
  const output = path.join(baseDir, 'provider-catalog.ts');

  // Generate import statements
  const imports = providers.map(
    ({ className, importPath }) => `import { ${className} } from '${importPath}';`
  ).join('\n');

  // Generate catalog entries
  const catalogEntries = providers.map(
    ({ name, className }) => `  '${name}': ${className}`
  ).join(',\n');

  const content = `// AUTO-GENERATED - DO NOT EDIT MANUALLY
// Generated by scripts/generate-provider-registry.ts
//
// This file is automatically generated at build time from provider implementations.
// To add a new provider, create a *-provider.ts file implementing AIProvider.

import type { AIProvider } from './types';

// Provider class imports (auto-generated)
${imports}

/**
 * Provider constructor type
 */
export type ProviderConstructor = new () => AIProvider;

/**
 * Auto-generated catalog of AI providers
 *
 * Maps provider names to their class constructors.
 * Generated at build time by scanning provider implementations.
 */
export const PROVIDER_CATALOG: Record<string, ProviderConstructor> = {
${catalogEntries}
};
`;

  await fs.writeFile(output, content, 'utf-8');
  console.log(`[Provider Catalog] Generated: ${output}`);
  console.log(`[Provider Catalog] Total providers: ${providers.length}`);
}

// Run generation
generateCatalog()
  .then(() => {
    console.log('[Provider Catalog] Success!');
    process.exit(0);
  })
  .catch((err) => {
    console.error('[Provider Catalog] Failed:', err);
    process.exit(1);
  });
